===================================
AROS Application Development Manual
===================================

:Authors:   Staf Verhaegen, Sebastian Rittau, Stefan Rieken, Matt Parsons,
            Adam Chodorowski, Fabio Alemagna, Matthias Rustler
:Copyright: Copyright © 1995-2006, The AROS Development Team
:Version:   $Revision$
:Date:      $Date$
:Status:    Unfinished; integration started (looong way left to go).
:ToDo:      Integrate the various parts. Update and revise. Complete...

`Index <index>`__

.. Warning::

   This document is not finished! It is highly likely that many parts are
   out-of-date, contain incorrect information or are simply missing
   altogether. If you want to help rectify this, please contact us.

.. Contents::

-----------
dos.library
-----------

Program execution
=================

All AROS programs must return a program execution status. This status
expresses, if the program was executed successful, and if not, how serious
the case of failure was. In `dos/dos.h` the following constants are defined,
which represent the standard return states:

+ `RETURN_OK` is returned, if the program executed successfully.

+ `RETURN_WARN` means that the program executed successfully, but there was
  something not quite right. This could be returned, if for example a temporary
  file could not be deleted after use.

  `RETURN_WARN` is also returned to express a boolean state. In this case
  `RETURN_WARN` means true, while `RETURN_OK` means false.

+ `RETURN_ERROR` is returned on errors that caused the execution of the program
   to fail partly.

+ `RETURN_FAIL` is returned if the execution of the program failed completely.

+ As an alternative you can use the ANSI C return codes EXIT_SUCCESS and EXIT_FAILURE.


Files and directories
=====================

Paths
-----

FIXME: relative and absolute paths


Files
-----

FIXME

Reading files
~~~~~~~~~~~~~

FIXME


Writing and creating files
~~~~~~~~~~~~~~~~~~~~~~~~~~

FIXME


Directories
-----------

FIXME


Links
-----

Links are a method to apply multiple filenames to the same physical file or
directory. This way the file can be stored in multiple directories with
different filenames. There are two different types of links: hardlinks and
softlinks. A softlink is just a reference to another file by its name. This name
may be stated as relative or absolute path. If a softlink is accessed, AROS
tries to resolve the name of the file the link points to and redirects all
actions to that file. Of course, the file pointed to does not have to exist. It
may have been deleted after the link was created. Hardlinks are another instance
of the same file. They don't just reference the file by its name, they *are* the
file. Normally, a hardlink can't be distinguished from the orginal filename;
effectively the file has been given a second name. Due to this, hardlinks can
not be created over different volumes; they must be at the same volume.

.. Note::

    Not all filesystems support both types of links or any links at all.


FIXME

Low level file access (filehandlers)
------------------------------------

FIXME


Tasks, Processes and the Shell
------------------------------

Tasks
~~~~~

AROS is a multitasking operating system. This essentially means that multiple
programs may be run at the same time. Every program running is called a task.
But there are also tasks that are not user-programs. There are, for example,
tasks handling the file-system and tasks watching the input devices. Every task
gets a certain amount of time, in which it is running. After this time it's the
next task's turn; the system reschedules the tasks.

Plain tasks are very limited in their capabilities. Plain tasks must not call
a function of ``dos.library`` or a function that could call a function of
``dos.library`` (this includes ``OpenLibrary()`` for most cases!). Processes_
don't have this limitation.


The Task Structure
^^^^^^^^^^^^^^^^^^

A task is described by a struct ``Task`` as defined in ``exec/tasks.h``.
This structure contains information about the task like the its stack, its
signls and some management data. To get the address of a task strucure, use::

    #include <proto/exec.h>

    struct Task *FindTask( STRPTR name );

``name`` is a pointer to the name of the task to find. *Note that this name is
case-sensitive!* If the named task is not found, ``NULL`` is returned, otherwise
a pointer to a ``struct Task``.

To get a pointer to the current task, supply ``NULL`` as ``name``. This can
never fail.

The task structure contains a field called ``tc_UserData``. You can use it for
your own purposes. It is ignored by AROS.


States
^^^^^^

A task must be in one of following states (as set in the field
`tc_State` of the task structure):

TS_INVALID
    This state should never be set!

TS_ADDED
    FIXME

TS_RUN
    The task is currently running. On single processor architectures only
    one task can be in that state.

TS_READY
    The task waits for its execution.

TS_WAIT
    The task waits for some
    .. FIXME: *signal*
    to get activated. As long as this does not
    happen, the program doesn't become active; it is ignored on rescheduling.
    Most interactive programs are in this state most of the time, as they wait
    for user input.

TS_EXCEPT
    The task is in an exception.

TS_REMOVED
    FIXME

.. Note::

    Do not set these states yourself, unless you know exactly what you are
    doing!


Priorities
^^^^^^^^^^

The field ``tc_Node.ln_Pri`` of the ``struct Node`` embedded in the task
structure (see ``exec/nodes.h`` and the
.. FIXME:: *section about exec lists*
)
specifies the priority of the task. Possible priorities reach from ``-128`` to
``127``. The higher the priority the more processor time the task gets from the
system. To set a task's priority use the function::

    #include <proto/exec.h>

    BYTE SetTaskPri( struct Task *task, BYTE newpri );

The old priority is returned.


Stack
^^^^^

Every task has a stack. A stack is a piece of memory, in which a tasks stores
its temorary data. Compilers, for example, use the stack to store variables, you
use in your programs. On many architectures, the stack is also used to supply
library functions with parameters.

The size of the stack is limited. Therefore only a certain amount of data can be
stored in the stack. The stack-size of a task is chosen by its caller and must
be at least 4096 bytes. Tasks should generally not assume that their stack-size
is bigger. So, if a task needs more stack, the stack can be exchanged by using
the function::

    #include <proto/exec.h>

    void StackSwap( struct StackSwapStruct *sss );

The only argument, ``sss``, is a pointer to a ``struct StackSwapStruct`` as
defined in ``exec/tasks.h``.

``struct StackSwapStack`` must contain a pointer to the beginning of the new
stack (``strk_Lower``), to the end of the new stack (``stk_Upper``) and a new
stack-pointer (``stk_Pointer``). This stack-pointer is normally set either to
the same address as ``stk_Lower`` or to the same address as ``stk_Upper``,
depending on the kind of CPU used.

When calling `StackSwap()`, the ``StackSwapStruct`` structure supplied as
``sss`` will be filled with information about the current stack.

After finishing using the new stack, the old stack must be restored by calling
`StackSwap()` a second time with the same ``StackSwapStruct``.

.. Note::

    Normally, only compilers need this function. Handle it with great care as
    different architectures use the stack in different ways!


Processes
~~~~~~~~~

A process is an expanded task. Opposed to a task, it can use functions of
dos.library, because a process structure contains some special fields,
concerning files and directories. But of course, all functions that can be used
on tasks can also be used on processes.


The Process Structure
^^^^^^^^^^^^^^^^^^^^^

A process is described by a ``struct Process`` as defined in
``dos/dosextens.h``. The first field in ``struct Process`` is an embedded
``struct Task``. The extra fields include information about the file-system, the
console, the process is connected to, and miscellaneous other stuff.


Creating own Tasks and Processes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are mainly two methods of creating tasks and processes: you can either
call an external program (ie open an executable file and run the program
contained in it) or you can execute a piece of code, already in memory.


Starting External Programs
^^^^^^^^^^^^^^^^^^^^^^^^^^

External programs are always processes.
FIXME

Expanded Error Diagnostics
~~~~~~~~~~~~~~~~~~~~~~~~~~

Most functions of `dos.library` set the secondary error-code of the process
structure on error. This way the caller can determine, why a certain system-call
failed. Imagine, the function `Open()`, which opens a named file, fails. There
can be multiple reasons for this: maybe the file named doesn't exist, maybe it
is read protected. To find this out, you can query the secondary error-code set
by the last function by using::

	#include <proto/dos.h>

    LONG IoErr()

DOS-functions return one of the ``ERROR_`` definitions from
``dos/dos.h``. Applications can, of course, process these error-codes by
hand (which is useful in many cases), but often we just want to inform the user
what went wrong. (Applications normally need not care, if a file could not be
opened, because it did not exist or because it was read protected.) To output
human-readable error messages, dos.library provides two functions::

    #include <proto/dos.h>

    LONG Fault( LONG code, STRPTR header, STRPTR buffer, LONG length );
    BOOL PrintFault( LONG code, STRPTR header );

While `PrintFault()` simply prints an error message to the `standard output`,
`Fault()` fills a supplied buffer with the message. Both functions take
a ``code`` argument. This is the code to be converted into a string. You can
also supply a ``header`` string, which will prefix the error message. ``header``
may be ``NULL``, in which case nothing is prefixed.

`Fault()` also required a pointer to a ``buffer``, which is to be filled with
the converted string. The ``length`` of this buffer (in bytes) is to be passed
in as last argument. The total number of characters put into the buffer is
returned. You are on the safe side, if your buffer has a size for 83 character
plus the size of the header.

Examples for the use of these functions can be found in later chapters,
especially in the chapter about
.. FIXME:: *Files and Directories*.

Secondary error-codes of a program are handed back to the caller. If this is
a shell, the secondary error-code will be put into the field ``cli_Result2`` of
the shell structure (struct ``CommandLineInterface`` as defined in
``dos/dosextens.h`` and
.. FIXME:: *discussed later*.

You can also set the secondary error-code yourself. This way, you can either to
pass it back to another function in your program or to your caller. To set the
secondary error, use::

    #include <proto/dos.h>

    LONG SetIoErr( LONG code );

``code`` is the new secondary error-code and the old secondary error-code is
returned.



Stream I/O
----------

============================= ======================================================
`Open()`_
`OpenFromLock()`_
`Close()`_
`FGetC()`_
`UnGetC()`_
`FGets()`_
`FPutC()`_
`FPuts()`_
`FRead()`_
`FWrite()`_
`Flush()`_
`PutStr()`_
`Read()`_
`WaitForChar()`_
`Seek()`_
`LockRecord()`_
`LockRecords()`_
`UnLockRecord()`_
`UnLockRecords()`_
`VFPrintf()`_
`VFWritef()`_
`VPrintf()`_
`SetVBuf()`_
`Write()`_
`WriteChars()`_
`SelectInput()`_
`SelectOutput()`_
`SelectError()`_
`Input()`_
`Output()`_
`Error()`_
`AddBuffers()`_
`ChangeMode()`_
`Pipe()`_
============================= ======================================================


Files/Directories
-----------------

============================= ======================================================
`AssignAdd()`_
`AssignLate()`_
`AssignLock()`_
`AssignPath()`_
`RemAssignList()`_
`CreateDir()`_
`CurrentDir()`_
`ParentDir()`_
`ParentOfFH()`_
`DeleteFile()`_
`Rename()`_
`Relabel()`_
`SetVar()`_
`FindVar()`_
`GetVar()`_
`ScanVars()`_
`DeleteVar()`_
`MakeLink()`_
`ReadLink()`_
`SetFileSize()`_
`SetComment()`_
`SetFileDate()`_
`SetProtection()`_
`SetOwner()`_
`AddPart()`_
`FilePart()`_
`PathPart()`_
`SplitName()`_
`Format()`_
`StartNotify()`_
`EndNotify()`_
============================= ======================================================


Examination
-----------

============================= ======================================================
`Lock()`_
`DupLock()`_
`NameFromLock()`_
`ExAll()`_
`ExAllEnd()`_
`ExNext()`_
`Examine()`_
`MatchEnd()`_
`MatchFirst()`_
`MatchNext()`_
`MatchPattern()`_
`MatchPatternNoCase()`_
`ParsePattern()`_
`ParsePatternNoCase()`_
`SameDevice()`_
`SameLock()`_
`Info()`_
============================= ======================================================


Packets
-------

============================= ======================================================
`AbortPkt()`_
`DoPkt()`_
`ReplyPkt()`_
`SendPkt()`_
`WaitPkt()`_
============================= ======================================================


DOS entries
-----------

============================= ======================================================
`AddDosEntry()`_
`RemDosEntry()`_
`FreeDosEntry()`_
`AllocDosObject()`_
`FreeDosObject()`_
`AttemptLockDosList()`_
`FindDosEntry()`_
`LockDosList()`_
`UnLockDosList()`_
`MakeDosEntry()`_
`NextDosEntry()`_
`IsFileSystem()`_
`IsInteractive()`_
`Inhibit()`_
============================= ======================================================


Error
-----

============================= ======================================================
`DisplayError()`_
`ErrorReport()`_
`Fault()`_
`PrintFault()`_
`IoErr()`_
`SetIoErr()`_
============================= ======================================================


Arguments
---------

============================= ======================================================
`ReadArgs()`_
`ReadItem()`_
`FindArg()`_
`FreeArgs()`_
`GetArgStr()`_
`SetArgStr()`_
============================= ======================================================


Process
-------

============================= ======================================================
`CreateNewProc()`_
`CreateProc()`_
`AddSegment()`_
`NewLoadSeg()`_
`LoadSeg()`_
`UnLoadSeg()`_
`InternalLoadSeg()`_
`InternalUnLoadSeg()`_
`FindSegment()`_
`RemSegment()`_
`DeviceProc()`_
`CheckSignal()`_
`SetProgramName()`_
`GetProgramName()`_
`SetCurrentDirName()`_
`GetCurrentDirName()`_
`GetProgramDir()`_
`SetProgramDir()`_
`RunCommand()`_
`SystemTagList()`_
`Execute()`_
`Exit()`_
`GetDeviceProc()`_
`FreeDeviceProc()`_
`GetConsoleTask()`_
`SetConsoleTask()`_
`SetFileSysTask()`_
`GetFileSysTask()`_
`MaxCli()`_
`Cli()`_
`CliInitNewcli()`_
`CliInitRun()`_
`FindCliProc()`_
`SetPrompt()`_
`GetPrompt()`_
`SetMode()`_
============================= ======================================================


Misc.
-----

============================= ======================================================
`Delay()`_
`CompareDates()`_
`DateStamp()`_
`DateToStr()`_
`DosGetLocalizedString()`_
`DosGetString()`_
`StrToDate()`_
`StrToLong()`_
============================= ======================================================


.. _AbortPkt(): ../autodocs/dos#abortpkt
.. _AddBuffers(): ../autodocs/dos#addbuffers
.. _AddDosEntry(): ../autodocs/dos#adddosentry
.. _AddPart(): ../autodocs/dos#addpart
.. _AddSegment(): ../autodocs/dos#addsegment
.. _AllocDosObject(): ../autodocs/dos#allocdosobject
.. _AssignAdd(): ../autodocs/dos#assignadd
.. _AssignLate(): ../autodocs/dos#assignlate
.. _AssignLock(): ../autodocs/dos#assignlock
.. _AssignPath(): ../autodocs/dos#assignpath
.. _AttemptLockDosList(): ../autodocs/dos#attemptlockdoslist
.. _ChangeMode(): ../autodocs/dos#changemode
.. _CheckSignal(): ../autodocs/dos#checksignal
.. _Cli(): ../autodocs/dos#cli
.. _CliInitNewcli(): ../autodocs/dos#cliinitnewcli
.. _CliInitRun(): ../autodocs/dos#cliinitrun
.. _Close(): ../autodocs/dos#close
.. _CompareDates(): ../autodocs/dos#comparedates
.. _CreateDir(): ../autodocs/dos#createdir
.. _CreateNewProc(): ../autodocs/dos#createnewproc
.. _CreateProc(): ../autodocs/dos#createproc
.. _CurrentDir(): ../autodocs/dos#currentdir
.. _DateStamp(): ../autodocs/dos#datestamp
.. _DateToStr(): ../autodocs/dos#datetostr
.. _Delay(): ../autodocs/dos#delay
.. _DeleteFile(): ../autodocs/dos#deletefile
.. _DeleteVar(): ../autodocs/dos#deletevar
.. _DeviceProc(): ../autodocs/dos#deviceproc
.. _DisplayError(): ../autodocs/dos#displayerror
.. _DoPkt(): ../autodocs/dos#dopkt
.. _DosGetLocalizedString(): ../autodocs/dos#dosgetlocalizedstring
.. _DosGetString(): ../autodocs/dos#dosgetstring
.. _DupLock(): ../autodocs/dos#duplock
.. _EndNotify(): ../autodocs/dos#endnotify
.. _Error(): ../autodocs/dos#error
.. _ErrorReport(): ../autodocs/dos#errorreport
.. _ExAll(): ../autodocs/dos#exall
.. _ExAllEnd(): ../autodocs/dos#exallend
.. _ExNext(): ../autodocs/dos#exnext
.. _Examine(): ../autodocs/dos#examine
.. _Execute(): ../autodocs/dos#execute
.. _Exit(): ../autodocs/dos#exit
.. _FGetC(): ../autodocs/dos#fgetc
.. _FGets(): ../autodocs/dos#fgets
.. _FPutC(): ../autodocs/dos#fputc
.. _FPuts(): ../autodocs/dos#fputs
.. _FRead(): ../autodocs/dos#fread
.. _FWrite(): ../autodocs/dos#fwrite
.. _Fault(): ../autodocs/dos#fault
.. _FilePart(): ../autodocs/dos#filepart
.. _FindArg(): ../autodocs/dos#findarg
.. _FindCliProc(): ../autodocs/dos#findcliproc
.. _FindDosEntry(): ../autodocs/dos#finddosentry
.. _FindSegment(): ../autodocs/dos#findsegment
.. _FindVar(): ../autodocs/dos#findvar
.. _Flush(): ../autodocs/dos#flush
.. _Format(): ../autodocs/dos#format
.. _FreeArgs(): ../autodocs/dos#freeargs
.. _FreeDeviceProc(): ../autodocs/dos#freedeviceproc
.. _FreeDosEntry(): ../autodocs/dos#freedosentry
.. _FreeDosObject(): ../autodocs/dos#freedosobject
.. _GetArgStr(): ../autodocs/dos#getargstr
.. _GetConsoleTask(): ../autodocs/dos#getconsoletask
.. _GetCurrentDirName(): ../autodocs/dos#getcurrentdirname
.. _GetDeviceProc(): ../autodocs/dos#getdeviceproc
.. _GetFileSysTask(): ../autodocs/dos#getfilesystask
.. _GetProgramDir(): ../autodocs/dos#getprogramdir
.. _GetProgramName(): ../autodocs/dos#getprogramname
.. _GetPrompt(): ../autodocs/dos#getprompt
.. _GetVar(): ../autodocs/dos#getvar
.. _Info(): ../autodocs/dos#info
.. _Inhibit(): ../autodocs/dos#inhibit
.. _Input(): ../autodocs/dos#input
.. _InternalLoadSeg(): ../autodocs/dos#internalloadseg
.. _InternalUnLoadSeg(): ../autodocs/dos#internalunloadseg
.. _IoErr(): ../autodocs/dos#ioerr
.. _IsFileSystem(): ../autodocs/dos#isfilesystem
.. _IsInteractive(): ../autodocs/dos#isinteractive
.. _LoadSeg(): ../autodocs/dos#loadseg
.. _Lock(): ../autodocs/dos#lock
.. _LockDosList(): ../autodocs/dos#lockdoslist
.. _LockRecord(): ../autodocs/dos#lockrecord
.. _LockRecords(): ../autodocs/dos#lockrecords
.. _MakeDosEntry(): ../autodocs/dos#makedosentry
.. _MakeLink(): ../autodocs/dos#makelink
.. _MatchEnd(): ../autodocs/dos#matchend
.. _MatchFirst(): ../autodocs/dos#matchfirst
.. _MatchNext(): ../autodocs/dos#matchnext
.. _MatchPattern(): ../autodocs/dos#matchpattern
.. _MatchPatternNoCase(): ../autodocs/dos#matchpatternnocase
.. _MaxCli(): ../autodocs/dos#maxcli
.. _NameFromLock(): ../autodocs/dos#namefromlock
.. _NewLoadSeg(): ../autodocs/dos#newloadseg
.. _NextDosEntry(): ../autodocs/dos#nextdosentry
.. _Open(): ../autodocs/dos#open
.. _OpenFromLock(): ../autodocs/dos#openfromlock
.. _Output(): ../autodocs/dos#output
.. _ParentDir(): ../autodocs/dos#parentdir
.. _ParentOfFH(): ../autodocs/dos#parentoffh
.. _ParsePattern(): ../autodocs/dos#parsepattern
.. _ParsePatternNoCase(): ../autodocs/dos#parsepatternnocase
.. _PathPart(): ../autodocs/dos#pathpart
.. _Pipe(): ../autodocs/dos#pipe
.. _PrintFault(): ../autodocs/dos#printfault
.. _PutStr(): ../autodocs/dos#putstr
.. _Read(): ../autodocs/dos#read
.. _ReadArgs(): ../autodocs/dos#readargs
.. _ReadItem(): ../autodocs/dos#readitem
.. _ReadLink(): ../autodocs/dos#readlink
.. _Relabel(): ../autodocs/dos#relabel
.. _RemAssignList(): ../autodocs/dos#remassignlist
.. _RemDosEntry(): ../autodocs/dos#remdosentry
.. _RemSegment(): ../autodocs/dos#remsegment
.. _Rename(): ../autodocs/dos#rename
.. _ReplyPkt(): ../autodocs/dos#replypkt
.. _RunCommand(): ../autodocs/dos#runcommand
.. _SameDevice(): ../autodocs/dos#samedevice
.. _SameLock(): ../autodocs/dos#samelock
.. _ScanVars(): ../autodocs/dos#scanvars
.. _Seek(): ../autodocs/dos#seek
.. _SelectError(): ../autodocs/dos#selecterror
.. _SelectInput(): ../autodocs/dos#selectinput
.. _SelectOutput(): ../autodocs/dos#selectoutput
.. _SendPkt(): ../autodocs/dos#sendpkt
.. _SetArgStr(): ../autodocs/dos#setargstr
.. _SetComment(): ../autodocs/dos#setcomment
.. _SetConsoleTask(): ../autodocs/dos#setconsoletask
.. _SetCurrentDirName(): ../autodocs/dos#setcurrentdirname
.. _SetFileDate(): ../autodocs/dos#setfiledate
.. _SetFileSize(): ../autodocs/dos#setfilesize
.. _SetFileSysTask(): ../autodocs/dos#setfilesystask
.. _SetIoErr(): ../autodocs/dos#setioerr
.. _SetMode(): ../autodocs/dos#setmode
.. _SetOwner(): ../autodocs/dos#setowner
.. _SetProgramDir(): ../autodocs/dos#setprogramdir
.. _SetProgramName(): ../autodocs/dos#setprogramname
.. _SetPrompt(): ../autodocs/dos#setprompt
.. _SetProtection(): ../autodocs/dos#setprotection
.. _SetVBuf(): ../autodocs/dos#setvbuf
.. _SetVar(): ../autodocs/dos#setvar
.. _SplitName(): ../autodocs/dos#splitname
.. _StartNotify(): ../autodocs/dos#startnotify
.. _StrToDate(): ../autodocs/dos#strtodate
.. _StrToLong(): ../autodocs/dos#strtolong
.. _SystemTagList(): ../autodocs/dos#systemtaglist
.. _UnGetC(): ../autodocs/dos#ungetc
.. _UnLoadSeg(): ../autodocs/dos#unloadseg
.. _UnLockDosList(): ../autodocs/dos#unlockdoslist
.. _UnLockRecord(): ../autodocs/dos#unlockrecord
.. _UnLockRecords(): ../autodocs/dos#unlockrecords
.. _VFPrintf(): ../autodocs/dos#vfprintf
.. _VFWritef(): ../autodocs/dos#vfwritef
.. _VPrintf(): ../autodocs/dos#vprintf
.. _WaitForChar(): ../autodocs/dos#waitforchar
.. _WaitPkt(): ../autodocs/dos#waitpkt
.. _Write(): ../autodocs/dos#write
.. _WriteChars(): ../autodocs/dos#writechars
