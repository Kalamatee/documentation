===================================
AROS Application Development Manual
===================================

:Authors:   Staf Verhaegen, Sebastian Rittau, Stefan Rieken, Matt Parsons,
            Adam Chodorowski, Fabio Alemagna, Matthias Rustler
:Copyright: Copyright © 1995-2006, The AROS Development Team
:Version:   $Revision$
:Date:      $Date$
:Status:    Unfinished
:ToDo:      Complete...

`Index <index>`__

.. Warning::

   This document is not finished! It is highly likely that many parts are
   out-of-date, contain incorrect information or are simply missing
   altogether. If you want to help rectify this, please contact us.

.. Contents::

---------------------
The AROS build system
---------------------

Development tools used by AROS
==============================

AROS uses several development tools in its building system. A short list of
the most important ones is:

+ *GNU make*: the GNU version of the make program. It is assumed that the AROS
  programmers are familiar with this program. Also the GNU specific extensions
  are used heavily. The GNU info pages about the `make` program are a good
  documentation.
+ *MetaMake*: A make supervisor program. It can keep track of targets
  available in makefiles which exist in subdirectories of a certain root directory.
  A more in depth explanation is given below.
+ *genmf*: (generate makefile) A macro language for makefiles. It allows to
  combine several make rules into one macro. This can simplify writing
  makefiles.
+ Several AROS specific tools that will be explained more when appropriate
  during the rest of this documentation.


MetaMake
--------

Introduction
""""""""""""

`MetaMake` is a version of `make` which allows to recursively build targets in the
various directories of a project or even another project. It searches
a directory tree for makefiles and all makefiles it finds for "metatargets". Then
it tries to build all metatargets. You can also specify a program which
converts "source" makefiles into makefiles before `MetaMake` will invoke `make`.

Syntax of the makefile
""""""""""""""""""""""

`MetaMake` uses normal makefile syntax but gives a special meaning to a
comment line that starts with ``#MM``. This line is used to define so called
metatargets. The name of the makefile itself is defined in the `MetaMake`
config file that is discussed in one of the following sections.

There exist three ways of defining a metatarget in a makefile:

+ This defines a metatarget with its metaprerequisites::

      #MM metatarget : metaprerequisites

  When a user asks to build this metatarget, first the metaprerequisites will
  be build as metatargets and afterwards the given metatarget.

  This form also indicates that in this makefile also a makefile target is
  present with the same name. This makefile target has to be defined, yet.

+ This is the same definition as in the previous paragraph, but now no
  normal make target is present in the makefile with the same name as the
  metatarget. Using this 'virtual' metatargets speeds up the build because
  `make` isn't called with this target::

      #MM- metatarget : metaprerequisites

+ This form defines both a metatarget and a `make` target with the same name.
  The prerequisites are no metaprerequisites::

      #MM
      metatarget : prerequisites

The line for the definition of a metatarget can be spread over several lines
if you end every line with the \\ character and start the next line with
``#MM``.

You can define a metatarget with the same name in several files. The metaprerequisites
are then collected.

If a metatarget is defined both with ``#MM`` and ``#MM-`` the ``#MM`` has priority. 


How MetaMake works
""""""""""""""""""

`MetaMake` is run by calling ``make`` in the root directory of the AROS source tree.

At first `MetaMake` will build up a tree of all the makefiles present in
a root directory and all subdirectories. At the same time it will also build
a tree of all the metatargets and their dependencies.

Next it will build all the metaprerequisites needed for this metatarget and
then finally the metatarget itself. Actually someone can look at it that every
metaprerequisite becomes a metatarget when it needs to be build. For each of
these metatargets a walk through of all the directories is done. In every
makefile where the metatarget is defined by the first or third way from the
previous section `make` is called with the name of the target as a `make`
target.

When `MetaMake` calls normal `make` also two variables are defined. $(TOP) has
the value of the root directory and $(CURDIR) the path relative to this root
directory.

Metatargets which aren't a prerequisite of another target aren't build by default.
If you want to build such a metatarget you have to type ``make`` `metatarget`
in the root directory of the AROS source tree.

Autogenerated makefiles
"""""""""""""""""""""""

Another feature of `MetaMake` is automatic generating a makefile from a source
makefile. When the directory tree is scanned for all the makefiles in every
directory it is checked if a makefile is present with a .src suffix added.
If it is there and is newer than the makefile present in that directory a
script will be called to regenerate the makefile from the source makefile.
What script has to be called is defined in the configuration file.

Examples
""""""""

The next few examples are taken from the AROS project.

Example 1: normal dependencies
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #MM contrib-regina-module : setup linklibs includes contrib-regina-includes

This example says that in this makefile a `contrib-regina-module` is present
that has to be build. Before building this metatarget first the
metatargets `setup`, `linklibs`, ... have to be build; this ensures that the includes,
linklibs etc. have to be present before this module can be build.

Example 2: metatarget consisting of submetatargets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

   #MM- contrib-freetype : contrib-freetype-linklib \
   #MM      contrib-freetype-graph \
   #MM      contrib-freetype-fonts \
   #MM      contrib-freetype-demos

Here actually is said that the `contrib-freetype` metatarget requires building of
`linklib`, `graph`, `fonts` and `demos` of `freetype`. If some extra work
needs to be done in the makefile where this metatarget is, the definition can
start with ``#MM`` and a normal `make` target `contrib-freetype` has to be
present in the makefile.

Also the use of the line continuation for the metatarget definition is shown
here.

Example 3: Quick building of a target
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

::

    #MM workbench-utilities : includes linklibs setup-clock-catalogs
    #MM
    workbench-utilities-quick : workbench-utilities

When a user executes `MetaMake` with as argument `workbench-utilities` `make` will
be called in all the directories where the metaprerequisites are present in
the makefile. This can become quite annoying when debugging programs. When
now the second metatarget `workbench-utilities-quick` is defined as shown
above only that target will be build in this directory. Of course the user
has then to be sure that the metatargets on which `workbench-utilities` depend
are up-to-date.


Configuration file
""""""""""""""""""

The `MetaMake` configuration file has the path $(TOP)/mmake.config. A short
explanation of its content:

``[AROS]``
    Begins a config section for the project `AROS`

``maketool $(HOST_MAKE) $(MKARGS) TOP=$(TOP) CURDIR=$(CURDIR) TARGET=$(TARGET)``
    Specifies the name of the tool to build a target. This is usually `make`.

``defaultmakefilename mmakefile``
    This defines `mmakefile` as name for `MetaMake` makefiles.

``genmakefilescript $(GENMF) $(TOP)/config/make.tmpl --listfile $(MMLIST)``
    `MetaMake` allows to generate makefiles with a script. The makefile
    will be regenerated if it doesn't exist, if the source file is
    newer or if the file specified with `genmakefiledeps` is newer.
    The name of the source file is generated by concatenating
    `defaultmakefilename` and ".src"

``genmakefiledeps $(GENMF) $(TOP)/config/make.tmpl``
    If this file is newer than the makefile, the given script will be executed.

``globalvarfile $(TOP)/bin/$(AROS_HOST_ARCH)-$(AROS_HOST_CPU)/gen/config/host.cfg``
    `MetaMake` will read this file and every variable in this file will
    be available everywhere where you can use a variable.

``genglobalvarfile sh $(TOP)/configure``
    This defines a script to regenerate the `globalvarfile`.

``ignoredir ...``
    This tells `MetaMake` to ignore these directories.


Genmf
-----

Introduction
""""""""""""

`Genmf` uses two files for generating a makefile. First is the macro definition
file and finally the source makefile (mmakefile.src) where these macros can be used.
The macros for AROS are in the file $(TOP)/config/make.tmpl.

Syntax
""""""

In general the ``%`` character is used as the special character for genmf
source makefiles.


Macro definition
^^^^^^^^^^^^^^^^

A macro definition has the following syntax::

    %define macroname option1[=[default][\A][\M]] option2[=[default][\A][\M]] ...
    ...
    %end

`macroname` is the name of the macro. `option1`, `option2`, ... are the arguments
for the macro. These options can be used in the body of this template by
typing %(option1). This will be replaced be the value of option1.

The argument can be followed by a default value. If no default value is
specified an empty string is taken. Normally no spaces are allowed in the
default value of an argument. If this is needed this can be done by
surrounding the value with double quotes (``"``).

Also two switches can be given:

    ``\A``
        Is the switch to always need a value for this. When the macro is
        instantiated always a value needs to be assigned to this argument.

    ``\M``
        Is the switch to turn on multi words. This means that all the words
        following this argument will be assigned to this argument. This also
        means that after the use of such an argument no other argument can be
        present because it will become part of this argument.


Macro instantiation
^^^^^^^^^^^^^^^^^^^

The instantiation of the macro is done by using the '%' character followed
by the name of the macro to instantiate (without round brackets around it)::

    %macro_name [option1=]value [option2=]value

Two ways are possible to specify value for arguments to a macro:

    ``value``
        This will assign the first value to the first argument, the second value
	to the second argument and so on.

    ``option1=value``
        This will assign the given value to the option with the specified
        name.

When giving values to arguments also double quotes need to be used if someone
wants to include spaces in the values of the arguments.

Macro instantiation may be used inside the body of a macro, even macros
that will only be defined later on in the macro definition file.

.. Note:: In the definition of the genmf rules sometimes `MetaMake` variables are
          used as default variables for an argument (e.g. ``dflags=%(cflags)``).
          This is not really possible in the definition file but is done by
          using text that has the same effect.


AROS usage of the build tool
============================

High level mmakefile.src macros
-------------------------------

AROS standard metamake targets
""""""""""""""""""""""""""""""

The following metatargets are often used as prerequisite:

+ ``includes``: the \*.h files
+ ``linklibs``: static linker libraries

FIXME: complete


Building programs
"""""""""""""""""

There are two macros for building programs. One macro ``%build_progs``
that will compile every input file to a separate executable and one macro
``%build_prog`` that will compile and link all the input files into one
executable.

%build_progs
^^^^^^^^^^^^

This macro will compile and link every input file to a separate executable
and has the following definition::

    %define build_progs mmake=/A files=/A \
        objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    	cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    	uselibs= usehostlibs= usestartup=yes detach=no

With the following arguments:

    ``mmake=/A``
        This is the name of the metatarget that will build the programs. Also a
        ``%(mmake)-quick`` metatarget will be defined.

    ``files=/A``
        The basenames of the C source files that will be compiled and linked
        to executables. For every name present in this list an executable
        with the same name will be generated.

    ``objdir=$(GENDIR)/$(CURDIR)``
        The directory where the compiled object files will be put.

    ``targetdir=$(AROSDIR)/$(CURDIR)``
        The directory where the executables will be placed.

    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``ldflags=$(LDFLAGS)``
        The flags to use when linking the executables. By default the
        standard AROS link flags will be used.

    ``uselibs=``
        A list of static libraries to add when linking the executables. This is
        the name of the library without the `lib` prefix or the `.a` suffix and
        without the `-l` prefix for the use in the flags for the C compiler.

        By default no libraries are used when linking the executables.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the
        executables. This is the name of the library without the `lib` prefix or
        the `.a` suffix and without the `-l` prefix for the use in the flags for
        the C compiler.

        By default no libraries are used when linking the executables.

    ``usestartup=yes``
        Use the standard startup code for the executables. By default this
        is yes and this is also what someone wants most of the time. Only disable
        this if you know what you are doing.

    ``detach=no``
        Whether the executables will run detached. Defaults to no.

%build_prog
^^^^^^^^^^^

This macro will compile and link the input files to an executable
and has the following definition::

    %define build_prog mmake=/A progname=/A files=%(progname) asmfiles= \
        objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
        cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
        aflags=$(AFLAFS) uselibs= usehostlibs= usestartup=yes detach=no

With the following arguments:

    ``mmake=/A``
        This is the name of the metatarget that will build the program. Also a
        ``%(mmake)-quick`` metatarget will be defined.

    ``progname=/A``
        The name of the executable.

    ``files=``
        The basenames of the C source files that will be compiled and linked
        into the executable. By default just the name of the executable is
        taken.

    ``asmfiles=``
        The assembler files to assemble and include in the executable. By
        default no asm files are included in the executable.

    ``objdir=$(GENDIR)/$(CURDIR)``
        The directory where the compiled object files will be put.

    ``targetdir=$(AROSDIR)/$(CURDIR)``
        The directory where the executables will be placed.

    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variable) are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``aflags=$(AFLAGS)``
        The flags to add when compiling the asm files. By default the standard
        AROS aflags (e.g. ``$(AFLAGS)``) are taken. This also
        means that some flags can be added by assigning these to the
        SPECIAL_AFLAGS make variable before using this macro.

    ``ldflags=$(LDFLAGS)``
        The flags to use when linking the executable. By default the
        standard AROS link flags will be used.

    ``uselibs=``
        A list of static libraries to add when linking the executable. This is
        the name of the library without the `lib` prefix or the `.a` suffix and
        without the `-l` prefix for the use in the flags for the C compiler.

        By default no libraries are used when linking the executable.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the
        executable. This is the name of the library without the `lib` prefix or
        the `.a` suffix and without the `-l` prefix for the use in the flags for
        the C compiler.

        By default no libraries are used when linking the executable.

    ``usestartup=yes``
        Use the standard startup code for the executables. By default this
        is yes and this is also what someone wants most of the time. Only disable
        this if you know what you are doing.

    ``detach=no``
        Whether the executable will run detached. Defaults to no.


Common
""""""

    %define common

This adds some common stuff like a `clean` target to the makefile. The `clean`
target only deletes generated makefiles.

 
Building catalogs
"""""""""""""""""

The definition of the macro is as follows::

    %define build_catalogs mmake=/A name=/A subdir=/A \
      catalogs="$(basename $(wildcard *.ct))" source="../strings.h" \
      description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS) \
      sourcedescription="$(TOOLDIR)/C_h_orig"

With the meaning of the arguments as follows:

    ``mmake=/A``
        This is the name of the metatarget that will build the catalogs. Also a
        ``%(mmake)-clean`` metatarget will be defined.


    ``name=/A``
        This is the name of the destination catalog, without the .catalog suffix.

    ``subdir=A``
        This is the destination subdir of the catalogs.

    ``catalogs``
        This is the list of catalogs, without the .ct suffix (default \*.ct)

    ``source``
        This is the path to the generated source code file. The default value
        creates the file `strings.h` in the parent directory. Remember that
        generated files must not be committed to SVN.

    ``description``
        This is the catalog description file (.cd) (default \*.cd).

    ``dir``
        This is the base destination directory (default $(AROS_CATALOGS)).

    ``sourcedescription``
        This is the path to the FlexCat's source description file, without the .sd suffix.

Example::

    %build_catalogs mmake=workbench-system-wanderer-tools-info-catalogs \
    name=Info subdir=System/System/Wanderer/Tools


Building icons
""""""""""""""

Creates icons. The images must be in `PNG` or `ILBM` format. The icon is configured from
an additional text file with the name %(iconname).info.src. You can find the documentation
of this file in $(TOP)/tools/ilbmtoicon/README

The definition of the macro is as follows::

    %define build_icons mmake=/A icons=/A dir=/A

With the meaning of the arguments as follows:

    ``mmake``
        This is the name of the metatarget. Also a
        ``%(mmake)-clean`` metatarget will be defined.

    ``icons``
        This is a list of icon base names (without the .info suffix).

    ``dir``
        This is the destination directory.

Example::

    %build_icons mmake=workbench-system-wanderer-tools-newdrawer-icons \
    icons=newdrawer dir=$(AROS_WANDERER)/Tools

The definition file has the name newdrawer.info.src.


Building static linklibraries
"""""""""""""""""""""""""""""

Building link libraries is straight forward. A list of files will be
compiled or assembled and collected in a link library into a specified
target directory.

The definition of the macro is as follows::

    %define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c)) \
      asmfiles= cflags=$(CFLAGS) dflags=%(cflags) aflags=$(AFLAGS) \
      objdir=$(OBJDIR) libdir=$(LIBDIR)

With the meaning of the arguments as follows:

    ``mmake=/A``
        This is the name of the metatarget that will build the linklib.

    ``libname=/A``
        The base name of the library to generate. The file that will be
        generated will be called lib%(libname).a

    ``files=$(basename $(wildcard *.c))``
        The C files to compile and include in the library. By default all
        the files ending in .c in the source directory will be used.

    ``asmfiles=``
        The assembler files to assemble and include in the library. By
        default no asm files are included in the library.

    ``cflags=$(CFLAGS)``
        The flags to use when compiling the .c files. By default the standard
        AROS cflags (e.g. ``$(CFLAGS)``) are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``aflags=$(AFLAGS)``
        The flags to add when compiling the asm files. By default the standard
        AROS aflags (e.g. ``$(AFLAGS)``) are taken. This also
        means that some flags can be added by assigning these to the
        SPECIAL_AFLAGS make variable before using this macro.

    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.

    ``libdir=$(LIBDIR)``
        The directory to put the library in. By default the standard library
        directory ``$(LIBDIR)`` will be used.

Building modules
""""""""""""""""

Building modules consists of two parts. First is a macro to use in
mmakefile.src files. Another is a configuration file that describes the
contents of the module.

The mmakefile.src macro
^^^^^^^^^^^^^^^^^^^^^^^

This is the definition header of the build_module macro::

    %define build_module mmake=/A modname=/A modtype=/A            \
      conffile=%(modname).conf files="$(basename $(wildcard *.c))" \
      cflags=$(CFLAGS) dflags=%(cflags) objdir=$(OBJDIR)           \
      linklibname=%(modname) uselibs=

Here is a list of the arguments for this macro:

    ``mmake=/A``
        This is the name of the metatarget that will build the module. Also a
        ``%(mmake)-quick`` and ``%(mmake)-clean`` metatarget will be defined.

    ``modname=/A``
        This is the name of the module without the suffix.

    ``modtype=/A``
        This is the type of the module and corresponds with the suffix of the
        module. At the moment only library, mcc, mui and mcp are supported.
        Support for other modules is planned in the future.

    ``conffile=%(modname).conf``
        The name of the configuration file. Default is modname.conf.

    ``files="$(basename $(wildcard *.c))"``
        A list of all the C source files without the .c suffix that contain the
        code for this module. By default all the .c files in the current
        directory will be taken.

    ``cflags=$(CFLAGS)``
        The flags to use when compiling the .c files. By default the standard
        AROS cflags (e.g. ``$(CFLAGS)``) are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.

    ``linklibname=%(modname)``
        The name to be used for the static link library that contains the
        library autoinit code and the stubs converting C stack calling
        convention to a call off the function from the library functable with
        the appropriate calling mechanism. These stubs are normally not needed
        when the AROS defines for module functions are not disabled.

        There will always be a file generated with the name
        ``$(LIBDIR)/lib%(linklibname).a`` and by default linklibname will be
        the same as modname.

    ``uselibs=``
        A list of static libraries to add when linking the module. This is the
        name of the library without the `lib` prefix or the `.a` suffix and
        without the `-l` prefix for the use in the flags for the C compiler.

        By default no libraries are used when linking the module.


The module configuration file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The module configuration file is subdivided in several sections. A section is
defined with the following lines::

    ## begin sectionname
    ...
    ## end sectionname

The interpretation of the lines between the ``##begin`` and ``##end``
statement is different for every section. The following sections are defined:

+ ``config``

  The lines in this section have all the same format::

      optionname string

  with the string starting from the first non white space after optionname
  to the last non white space character on that line.

  A list of all the options available:

  ``basename``
      Followed by the base name for this module. This will be used as a
      prefix for a lot of symbols. By default the modname specified in the
      makefile is taken with the first letter capitalized.

  ``libbase``
      The name of the variable to the library base in. By default the
      basename will be taken with Base added to the end.

  ``libbasetype``
      The type to use for the libbase for use internally for the library code.
      E.g. the sizeof operator applied to this type has to yield the real
      size of the object. Be aware that it may not be specified as a pointer.
      By default 'struct LibHeader' is taken.

  ``libbasetypeextern``
      The type to use for the libbase for code using the library externally.
      By default 'struct Library' is taken.

  ``version``
      The version to compile into the module. This has to be specified as
      major.minor. By default 0.0 will be used.

  ``date``
      The date that this library was made. This has to have the format of
      DD.MM.YYYY. As a default 00.00.0000 is taken.

  ``libcall``
      The argument passing mechanism used for the functions in this module.
      It can be either 'stack' or 'register'. By default 'stack' will be used.

  ``forcebase``
      This will force the use of a certain base variable in the static
      link library for auto opening the module. Thus it is only valid for
      module that support auto opening. This option can be present more then
      once in the config section and then all these base will be in the link
      library. By default no base variable will be present in the link
      library.

+ ``cdef``

  In this section all the C code has to be written that will declare all the
  type of the arguments of the function listed in the function. All valid C
  code is possible including the use of #include.

+ ``functionlist``

  In this section are all the functions that are externally accessible by programs.

  For stack based argument passing only a list of the functions has to be
  given. For register based argument passing the names of the register have
  to be given between rounded brackets. If you have function foo with the
  first argument in D0 and the second argument in A0 it gives the following
  line in in the list::

      foo(D0,A0)


Building modules (the legacy way)
"""""""""""""""""""""""""""""""""

Before the %build_module macro was developed already a lot of code was
written. There a mixture of macros was used in the mmakefile and they were
quite complicated. To clean up these mmakefiles without needing to rewrite
too much of the code itself a second genmf macro was created to build
modules that were written using the older methodology. This macro is called
build_module_macro. For writing new modules people should consider this
macro as deprecated and only use this macro when the %build_module doesn't
support the module yet they want to create.

The mmakefile.src macro
^^^^^^^^^^^^^^^^^^^^^^^

This is the definition header of the build_module_macro macro::

    %define build_module_macro mmake=/A modname=/A modtype=/A \
      conffile=%(modname).conf initfile=%(modname)_init \
      funcs= files= linklibfiles= cflags=$(CFLAGS) dflags=%(cflags) \
      objdir=$(OBJDIR) linklibname=%(modname) uselibs= usehostlibs= \
      genfunctable= genincludes= compiler=target

Here is a list of the arguments for this macro:

    ``mmake=/A``
        This is the name of the metatarget that will build the module. It will
        define that metatarget but won't include any metaprerequisites. If you
        need these you can add by yourself with an extra
        ``#MM metatargets : ...`` line. Also a ``%(mmake)-quick`` and
        ``%(mmake)-clean`` metatarget will be defined.

    ``modname=/A``
        This is the name of the module without the suffix.

    ``modtype=/A``
        This is the type of the module and corresponds with the suffix of the
        module. It can be one of the following : library gadget datatype
        handler device resource mui mcc hidd.

    ``conffile=%(modname).conf``
        The name of the configuration file. Default is modname.conf.

    ``funcs=``
        A list of all the source files with the .c suffix that contain the
        code for the function of a module. Only one function per C file is
        allowed and the function has to be defined using the AROS_LHA
        macros.

    ``files=``
        A list of all the extra files with the .c suffix that contain the
        extra code for this module.

    ``initfile=%(modname)_init``
        The file with the init code of the module.

    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``objdir=$(OBJDIR)``
        The directory where to generate all the intermediate files. The
        default value is ``$(OBJDIR)`` which in itself is by default equal to
        ``$(GENDIR)/$(CURDIR)``.

    ``linklibname=%(modname)``
        The name to be used for the static link library that contains the
        library autoinit code and the stubs converting C stack calling
        convention to a call off the function from the library functable with
        the appropriate calling mechanism. These stubs are normally not needed
        when the AROS defines for module function are not disabled.

        There will always be a file generated with the name
        ``$(LIBDIR)/lib%(linklibname).a`` and by default linklibname will be
        the same as modname.

    ``uselibs=``
        A list of static libraries to add when linking the module. This is the
        name of the library without the `lib` prefix or the `.a` suffix and
        without the `-l` prefix for the use in the flags for the C compiler.

        By default no libraries are used when linking the module.

    ``usehostlibs=``
        A list of static libraries of the host to add when linking the module. This
        is the name of the library without the `lib` prefix or the `.a` suffix
        and without the `-l`  prefix for the use in the flags for the C compiler.

        By default no libraries are used when linking the module.

    ``genfunctable=``
        Bool that has to have a value of yes or no or left empty. This
        indicates if the functable needs to be generated. If empty the
        functable will only be generated when funcs is not empty.

    ``genincludes=``
        Bool that has to have a value of yes or no or left empty. This
        indicates if the includes needs to be generated. If empty the
        includes will only be generated for a library, a gadget or a device.

    ``compiler=target``
        Indicates which compiler to use during compilation. Can be either
        target or host to use the target compiler or the host compiler.
        By default the target compiler is used.


For the build_module_macro two files are used. First is the module
configuration file (modname.conf or lib.conf) and second is the headers.tmpl
file.

The module configuration file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The modules config file is a file with a number of lines with the following
syntax:

    ``name <string>``
        Init the various fields with reasonable defaults. If <string> is XXX, then
        this is the result::

            libname         xxx
            basename        Xxx
            libbase         XxxBase
            libbasetype     XxxBase
            libbasetypeptr  XxxBase *

        Variables will only be changed if they have not yet been specified.

    ``libname <string>``
        Set libname to <string>. This is the name of the library (i.e. you can
        open it with <string>.library). It will show up in the version string, too.

    ``basename <string>``
        Set basename to <string>. The basename is used in the AROS-LHx macros in the
        location part (last parameter) and to specify defaults for libbase and
        libbasetype in case they have no value yet. If <string> is xXx, then
        libbase will become xXxBase and libbasetype will become	xXxBase.

    ``libbase <string>``
        Defines the name of the library base (i.e. SysBase, DOSBase, IconBase, etc).
        If libbasetype is not set, then it is set to <string>, too.

    ``libbasetype <string>``
        The type of libbase (with struct), i.e. struct ExecBase, struct DosLibrary,
        struct IconBase, etc).

    ``libbasetypeptr <string>``
        Type of a pointer to the libbase. (e.g. ``struct ExecBase *``).

    ``version <version>.<revision>``
        Specifies the version and revision of the library. 41.0103 means version 41
        and revision 103.

    ``copyright <string>``
        Copyright string.

    ``define <string>``
        The define to use to protect the resulting file	against double inclusion
        (i.e. #ifndef <string>...). The default is _LIBDEFS_H.

    ``type <string>``
        What kind of library is this ? Valid values for <string> are: device, library,
        resource and hidd.

    ``option <string>...``
        Specify an option. Valid values for <string> are:

        + ``noexpunge``

          Once the library/device is loaded, it can't be removed from memory.
          Be careful with this option.

        + ``rom``

          For ROM based libraries. Implies noexpunge and unique.

        + ``unique``

          Generate unique names for all external symbols.

        + ``nolibheader``

          We don't want to use the LibHeader prefixed functions in the
          function table.

        + ``hasrt``

          This library has resource tracking.

        You can specify more than one option in a config file and
        more than one option per option line. Separate options by
        space!

The header.tmpl file
^^^^^^^^^^^^^^^^^^^^

Contrary to the %build_module macro for %build_module_macro the C header
information is not included in the configuration file but an additional
files is used with the name headers.tmpl. This file has different section
where each of the sections will be copied in a certain include file that is
generated when the module is build. A section has a structure as follows::

    ##begin sectionname
    ...
    ##end sectionname

With sectionname one of the following choices:

+ defines
+ clib
+ proto


Compiling arch and/or CPU specific files
""""""""""""""""""""""""""""""""""""""""

In the previous paragraph the method was explained how a module can be build
with the AROS genmf macros. Sometimes someone wants to replace certain files in
a module with an implementation only valid for a certain arch or a certain
CPU.

The macro definition
^^^^^^^^^^^^^^^^^^^^

Arch specific files are handled by the macro called %build_archspecific and it
has the following header::

    %define build_archspecific mainmmake=/A maindir=/A arch=/A files= asmfiles= \
    cflags=$(CFLAGS) dflags=%(cflags) aflags=$(AFLAGS) compiler=target

And the explanation of the argument to this macro:

    ``mainmmake=/A``
        The mmake of the module from which someone wants to replace files or to
        which to add additional files.

    ``maindir=/A``
        The directory where the object files of the main module are stored.
        The is only the path relative to $(GENDIR). Most of the time this is the
        directory where the source files of the module are stored.

    ``arch=/A``
        The architecture for which these files needs to be build. It can
        have three different forms ARCH-CPU, ARCH or CPU. For example when
        linux-i386 is specified these files will only be build for the linux
        port on i386. With ppc it will be build for all ppc processors and
        with linux it will be build for all linux ports.

    ``files=``
        The basenames of the C source files to replace add to the module.

    ``asmfiles=``
        The basenames of the asm source files to replace or add to the module.

    ``cflags=$(CFLAGS)``
        The flags to add when compiling the .c files. By default the standard
        AROS cflags (the ``$(CFLAGS)`` make variables are taken. This also
        means that some flags can be added by assigning these to the
        USER_CFLAGS and USER_INCLUDES make variables before using this macro.

    ``dflags=%(cflags)``
        The flags to add when doing the dependency check. Default is the same
        as the ``cflags``.

    ``aflags=$(AFLAGS)``
        The flags to add when assembling the asm files. By default the standard
        AROS cflags (the ``$(AFLAGS)`` make variable) are taken. This also
        means that some flags can be added by assigning these to the
        SPECIAL_AFLAGS make variable before using this macro.

    ``compiler=target``
        Indicates which compiler to use during compiling C source files.
        Can be either target or host to use the target compiler or the
        host compiler. By default the target compiler is used.

Code shared by different ports
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A second macro called %rule_archalias allows to create a virtual
architecture. And code for that virtual architecture is shared between
several architectures. Most likely this is used for code that uses an
API that is shared between several architecture but not all of them.

The macro has the following header::

    %define rule_archalias mainmmake=/A arch=/A alias=/A

With the following arguments

    ``mainmmake=/A``
        The mmake of the module from which someone wants to replace files or to
        which to add additional files.

    ``arch=/A``
        The arch someone wants to make alias from.

    ``alias=/A``
        The arch someone wants to alias to.

Examples
^^^^^^^^

1. This is an extract from the file config/linux/exec/mmakefile.src that
   replaces the main init.c file from exec with a linux specialized one::

       %build_archspecific \
         mainmmake=kernel-exec maindir=rom/exec arch=linux \
         files=init compiler=host

2. For the dos.library some arch specific files are grouped together in the
   unix arch. The following lines are present in the several mmakefiles to
   make this possible

   In config/linux/mmakefile.src::

       %rule_archalias mainmmake=kernel-dos arch=linux alias=unix

   In config/freebsd/mmakefile.src::

       %rule_archalias mainmmake=kernel-dos arch=freebsd alias=unix

   And finally in config/unix/dos/mmakefile.src::

       %build_archspecific \
         mainmmake=kernel-dos maindir=rom/dos \
         arch=unix \
         files=boot \
         compiler=host

The file $(TOP)/config/make.tmpl contains more macros. See the comments in that file
for usage.

Lower level mmakefile.src macros
---------------------------------

FIXME

AROS portable makefile variables
--------------------------------

The file $(TOP)/config/make.cfg is usually included in all makefiles. It contains
a lot of variables which are often used in this makefiles. The most important are
the absolute paths for standard directories (e.g. `AROS_C`) and names for tools
(e.g. `MMAKE`, `GENMF`).

Platform depending definitions can be found in:

+ $(TOP)/bin/$(AROS_HOST_ARCH)-$(AROS_HOST_CPU)/gen/config/host.cfg
+ $(TOP)/bin/$(AROS_HOST_ARCH)-$(AROS_HOST_CPU)/gen/config/target.cfg
