=====================
AROS Debugging Manual
=====================

:Authors:   David Le Corfec
:Copyright: Copyright © 1995-2002, The AROS Development Team
:Version:   $Revision$
:Date:      $Date$
:Status:    Work in progress.

This manual explains the various options for AROS debugging.


.. Contents::


------------
Introduction
------------

For most developers, the easiest way to develop and debug is to use the
hosted AROS port under Linux (which is the most popular setting) or BSD.
This way you can use GDB under Linux to debug AROS. You'll need to pass
the ``--enable-debug`` to the configure script before compiling AROS.
Beware, debugging informations may decuple the disk size occupied by
the AROS tree.

Low-level hardware developers will rather use the serial debug output on
the native port.

Application developers need to ensure that their programs release all
the resources they take. AROS provides some tools for this.

-------------------------
Printing debug statements
-------------------------

::

    #define DEBUG 1
    #include <aros/debug.h>
    ...
    D(bug("value1=%ld, path=%s", value, path));

``D()`` will expand to nothing if ``DEBUG`` is 0 or undefined.
Use ``bug()`` alone to force debug output whatever is the value of ``DEBUG``.
The usage is the same as ``printf()``.
On hosted, the output will be displayed in the console where AROS
has been started.

---------------------------
With AROS hosted: using GDB
---------------------------

You can either run AROS under GDB, or use GDB after AROS has terminated
and left a core dump. Don't forget to compile AROS with debugging enabled
first (``./configure --enable-debug``).


Live debugging
==============

Start GDB like below::

    > cd /AROS/bin/linux-i386/AROS/
    > gdb aros
    GNU gdb 6.0-debian
    Copyright 2003 Free Software Foundation, Inc.
    GDB is free software, covered by the GNU General Public License, and you are
    welcome to change it and/or distribute copies of it under certain conditions.
    Type "show copying" to see the conditions.
    There is absolutely no warranty for GDB.  Type "show warranty" for details.
    This GDB was configured as "i386-linux"...
    (gdb) 

Then you run AROS with::

    (gdb) r
    Starting program: /AROS/bin/linux-i386/AROS/aros 
    (... lots of debug output follow ...)

Use Ctrl-C in the shell to interrupt AROS and get back to the GDB prompt.
Use ``help`` for help, or ``q`` to quit :)


Post-mortem debugging
=====================

First, you have to enable core dump generation, using eg. ulimit for the Bash shell.
Then run AROS and generate a core dump::

    > cd /AROS/bin/linux-i386/AROS/
    > ulimit -c unlimited # see your shell manual to enable core dumps
    > ./aros
    Quit (core dumped)

Now you can start GDB, by specifying the aros executable name and the core file::

    > gdb aros core
    GNU gdb 6.0-debian
    Copyright 2003 Free Software Foundation, Inc.
    GDB is free software, covered by the GNU General Public License, and you are
    welcome to change it and/or distribute copies of it under certain conditions.
    Type "show copying" to see the conditions.
    There is absolutely no warranty for GDB.  Type "show warranty" for details.
    This GDB was configured as "i386-linux"...
    Core was generated by `aros'.
    Program terminated with signal 3, Quit.
    Reading symbols from /usr/X11R6/lib/libX11.so.6...done.
    Loaded symbols for /usr/X11R6/lib/libX11.so.6
    Reading symbols from /usr/X11R6/lib/libXext.so.6...done.
    Loaded symbols for /usr/X11R6/lib/libXext.so.6
    Reading symbols from /lib/libc.so.6...done.
    Loaded symbols for /lib/libc.so.6
    Reading symbols from /lib/libdl.so.2...done.
    Loaded symbols for /lib/libdl.so.2
    Reading symbols from /lib/ld-linux.so.2...done.
    Loaded symbols for /lib/ld-linux.so.2
    #0  0x40125607 in sigsuspend () from /lib/libc.so.6
    (gdb)


GDB (basic commands)
====================

The command ``help`` gives help on all GDB commands::

    (gdb) help
    List of classes of commands:
    
    aliases -- Aliases of other commands
    breakpoints -- Making program stop at certain points
    data -- Examining data
    files -- Specifying and examining files
    internals -- Maintenance commands
    obscure -- Obscure features
    running -- Running the program
    stack -- Examining the stack
    status -- Status inquiries
    support -- Support facilities
    tracepoints -- Tracing of program execution without stopping the program
    tui -- Text User Interface commands
    user-defined -- User-defined commands
    
    Type "help" followed by a class name for a list of commands in that class.
    Type "help" followed by command name for full documentation.
    Command name abbreviations are allowed if unambiguous.
    (gdb) 

The command ``bt`` (backtrace) prints a backtrace of all stack frames.
Here is a backtrace after interrupting AROS with Ctrl-C in the GDB
console::

    Program received signal SIGINT, Interrupt.
    0x40125607 in sigsuspend () from /lib/libc.so.6
    (gdb) bt
    #0  0x40125607 in sigsuspend () from /lib/libc.so.6
    #1  0x080531d5 in idleTask (sysBase=0x40231290) at idletask.c:23
    #2  0x08052ba7 in Exec_NewAddTask (task=Cannot access memory at address 0x8
    ) at newaddtask.c:280
    Previous frame inner to this frame (corrupt stack?)
    (gdb) 

Innermost frame is #0.

To print the value of an expression accessible from the current frame,
use ``p`` (print)::

    (gdb) p SysBase
    $1 = (struct ExecBase *) 0x40231290

GDB's print command understands the C syntax, so you can print any valid
expression::

    (gdb) p SysBase->IntVects[2]
    $2 = {iv_Data = 0x0, iv_Code = 0x8052f30 <SoftIntDispatch>, iv_Node = 0x4023c528}

To move amongst frames, use the command ``f`` (frame) command::

    (gdb) f 1
    #1  0x080531d5 in idleTask (sysBase=0x40231290) at idletask.c:23
    23              sigsuspend(&sigs);

Use ``q`` to quit::

    (gdb) q
    The program is running.  Exit anyway? (y or n) y
    >


GDB (AROS-specific)
===================

AROS specific GDB commands are supplied in ``/AROS/_gdbinit``, which gets
installed to ``/AROS/bin/linux-i386/AROS/.gdbinit``.
This file is read by GDB on startup, and contains the following commands::

    findaddr - Shows the module that contains the given address
    thistask - Print out information about the currently running task.
    liblist - List the current libraries in the system
    devlist - List the current devices in the system
    resourcelist - List the current resources in the system
    residentlist - List the system resident list
    taskready - List of tasks current ready to run
    taskwait - List of tasks currently waiting for an event
    modlist - List of all the modules currently loaded in memory
    printtaglist - Display the given taglist

Of this list, ``findaddr`` is essential for proper debugging of non-ROM
code (shared libraries, applications ...)

Using findaddr
--------------

Most often you will want to debug librairies or applications, but a
backtrace gives you one or more unresolved adresses::

    0x4058d45b in ?? ()

Use ``findaddr`` on any address you want to resolve (probably the innermost)::

    (gdb) findaddr 0x4058d45b
    Searching in the loaded modules...
    Address found in Workbench:contrib/Zune/Libs/muimaster.library, which is loaded at 0x405379a4

Next you'll use the ``add-symbol-file`` command to load the given file::

    (gdb) add-symbol-file contrib/Zune/Libs/muimaster.library 0x405379a4
    add symbol table from file "contrib/Zune/Libs/muimaster.library" at
            .text_addr = 0x405379a4
    (y or n) y
    Reading symbols from contrib/Zune/Libs/muimaster.library...done.

Hopefully it has resolved the addresses::

    (gdb) bt
    #0  0x4058d45b in strlen (ptr=0x80 <Address 0x80 out of bounds>) at strlen.c:45
    (...)

Repeat for the remaining addresses you wish to resolve.

Using thistask
--------------

It displays several information from the currently running task. No surprise,
it is data you can find in ``SysBase->ThisTask``::

    (gdb) thistask 
    Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name
    -----------------------------------------------------------------------------
    40231fb8 00000000 00000000    40960      872 -128    1 Idle Task



-----------------
Resource tracking
-----------------

AROS provides some tools for this, either integrated in the OS, or as
separate programs.

Tracking memory with Mungwall
=============================

If configured with ``--enable-debug``, AROS enables ``Mungwall``. It keeps tracks of
a small zone before and after your allocations to verify that you don't write
out of your bounds. This check is done in memory allocation routines, or at
any time by calling ``Avail(MEMF_CLEAR)``.

The ``CheckMem`` command line tool just call this function, and reports to the
debug output (serial for native, or terminal for hosted). If no bound violation
has been detected, it will report the current number of allocation and their
total size::

    === MUNGWALL MEMORY CHECK ============
    
    Num allocations: 1579   Memory allocated 3333326

A neat trick is to modify the scheduler to call this function on each task switch,
when you have a strange memory corruption that you can't trace by other means.
It's slow, but there's no way the culprit can escape.

LeakWatch
=========

It's a dumb but helpful tool. It tracks down total memory and Exec objects:
libraries, devices, fonts, resources, ports and semaphores.
It triggers a flush of the unused objects still in memory to report
the real amount of memory after some resources are closed.

Launch ``LeakWatch`` in its own shell, then use the following keys:

+ ``Ctrl-C`` to quit :)
+ ``Ctrl-D`` to display the current state of resources
+ ``Ctrl-E`` to display resources differences since you launched it
+ ``Ctrl-F`` to display resources differences since the last time
  you hit ``Ctrl-F``.

``Ctrl-F`` is the most useful key: hit it before running your program, then after.
It should report no resources. In the opposite case:

+ Verify that no other program is allocating resources during this time
+ Repeat the runs. See if the leaks are consistent.
+ Narrow the place where the leak takes place by reducing the features
  you use, then by commenting out code.

If you think that your program triggered a leak in an AROS library,
find an existing test program or write a small one using the leaking
calls, to ensure that the leak really comes from there (as of 2004-01-21,
opening a TrueType font with OpenDiskFont leaks some bytes - see
``Tests/opendiskfont``).

Misc CLI tools
==============

There are also simpler debugging tools available in ``C:``.


AROS Shell
----------

Type ``set __debug_mem`` in the Shell to enable reporting available memory
before and after each command, as well as the memory difference. Mostly
the same as ``LeakWatch`` for memory only.

Avail
-----

Use ``Avail`` to display informations on memory. The FLUSH parameter
will force unused objects to be expunged.

Liblist
-------

It displays a list of the currently opened libraries as well as some infos
like version and open count.

Devlist
-------

Same as ``Liblist``, but for Exec Devices.
