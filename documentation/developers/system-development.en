==============================
AROS System Development Manual
==============================

.. Contents::


--------
MetaMake
--------

Introduction
============

MetaMake is a version of make which allows to recursively build targets in the
various directories of a project or even another project. It searches
a directory tree for makefiles and all makefiles it finds for "metatargets" and
then tries to build all metatargets. You can also specify a program which
converts "source" makefiles into makefiles before MetaMake will invoke make.

We use MetaMake to build AROS - The Amiga Research OS. AROS consists of many
different packages which depend on each other like this::

    #MM AROS : setup includes kernel workbench apps

This is a metatarget in a makefile (MetaMake looks for #MM as the first thing in
a line). It means that AROS depends on setup, includes, etc. as you are used to
from Make.

The big point is: MetaMake will consider *all makefiles at once* when it checks
a metatarget. So all metatargets "setup" in all makefiles will be build when
MetaMake tries to build AROS. MetaMake searches itself for the makefiles, so to
add a new package, just create a new makefile in that directory and invoke
MetaMake again.

This also allows to build the project from anywhere. You can invoke MetaMake in
a subdir or any other directory if you copy the config file to $HOME.

MetaMake can also read a file with Make-style variable definitions. This allows
to build the project depending on some variable, for example::

    #MM kernel : kernel-$(ARCH)-$(CPU)

will build kernel-linux-i386 before kernel on Linux/i386 machines.

MetaMake will calculate ``$(TOP)`` (the path to the top of the project) and
``CURDIR`` (the path to the current directory relative to ``$(TOP)``) and pass
them to make. Also ``$(TARGET)`` will contain the current target but this will
not be passed to make automatically. If you need the target in the makefile, you
can use the ``maketool`` option to change this.

For convenience, you can also let MetaMake find the target like this::

    #MM
    kernel : kernel-$(ARCH)-$(CPU)

but this is not the same as above. In this case, MetaMake will not try
to build ``kernel-$(ARCH)-$(CPU)`` but only ``kernel``.
This is useful if your metatarget doesn't depend on anything else
than local targets in the current makefile.

Usage and configuration files
=============================

``Usage: mmake [options] [metatargets]``

To build mmake, just compile ``mmake.c``. It doesn't need any
other files.

mmake looks for a config file ``mmake.config`` or
``.mmake.config`` in the current directory for a file in the
environment variable ``$MMAKE_CONFIG`` or a file ``.mmake.config``
in the directory ``$HOME``.
This file can contain the following things:


``#``
    This must be the first character in a line and begins a comment.
    Comments are completely ignored my mmake (as are empty lines).

``text="[<name>]"``
    This begins a config section for the project ``name``.
    You can build targets for this project by saying ``name.target``.

``maketool <tool options...>``
    Specifies the name of the tool to build a target. The
    default is ``make "TOP=$(TOP)" "CURDIR=$(CURDIR)"``.

``top <dir>`` 
    Specifies the root directory for a project. You
    will later find this config option in the variable ``$(TOP)``.
    The default is the current directory.

``defaultmakefilename <filename>``
    Specifies the basename for
    makefiles in your project. Basename means that mmake will consider
    other files which have this stem and an extension, too. See the
    items to generate makefiles for details. The default
    is ``Makefile``.

``defaulttarget <target>`` 
    The name of the default target which
    mmake will try to make if you call it with the name of the
    project alone. The default is ``all``.

``genmakefilescript <cmdline...>`` 
    mmake will check for files
    with the basename as specified in ``defaultmakefilename``
    with the extension ``.src``. If such a file is found, the
    following conditions are checked: Whether this file is newer
    than the makefile, whether the makefile doesn't exist and
    whether the file ``genmakefiledeps`` is newer than the
    makefile. If any of these is true, mmake will call this script
    the the name of the source file as an extra option and the
    stdout of this script will be redirected to ``defaultmakefilename``.
    If this is missing, mmake will not try to regenerate makefiles.

``genmakefiledeps <path>``
    This is the name of a file which is
    considered when mmake tries to decide whether a makefile must
    be regenerated. Currently, only one such file can be specified.

``globalvarfile <path>``
    This is a file which contains more
    variables in the normal make(1) syntax. mmake doesn't
    know about any special things like line continuation, so
    be careful not to use such variables later (but they
    don't do any harm if they exist in the file. You should
    just not use them anywhere in mmake).
    
``add <path>`` 
    Adds a nonstandard makefile to the list of
    makefiles for this project. mmake will apply the standard
    rules to it as if the ``defaultmakefilename`` was
    like this filename.
    
``ignoredir <path>``
    Will tell mmake to ignore directories
    with this name. Try ``ignore CVS`` if you use CVS to
    manage your projects' sources.

Any option which is not recognised will be added to the list
of known variables (ie. ``foo bar`` will create a
variable ``$(foo)`` which is expanded to ``bar``).

Example
=======

Here is an example::

    # This is a comment
    # Options before the first [name] are defaults. Use them for global
    # defaults
    defaultoption value
    
    # Special options for the project name. You can build targets for this
    # project with "mmake name.target"
    [AROS]
    
    # The root dir of the project. This can be accessed as $(TOP) in every
    # makefile or when you have to specify a path in mmake. The default is
    # the current directory
    top /home/digulla/AROS
    
    # This is the default name for Makefiles. The default is "Makefile"
    defaultmakefilename makefile
    
    # If you just say "mmake AROS", then mmake will go for this target
    defaulttarget AROS
    
    # mmake allows to generate makefiles with a script. The makefile
    # will be regenerated if it doesn't exist, if the source file is
    # newer or if the file specified with genmakefiledeps is newer.
    # The name of the source file is generated by concatenating
    # defaultmakefilename and ".src"
    genmakefilescript gawk -f $(TOP)/scripts/genmf.gawk --assign "TOP=$(TOP)"
    
    # If this file is newer than the makefile, the script
    # genmakefilescript will be executed.
    genmakefiledeps $(TOP)/scripts/genmf.gawk
    
    # mmake will read this file and every variable in this file will
    # be available everywhere where you can use a variable.
    globalvarfile $(TOP)/config/host.cfg
    
    # Some makefiles must have a different name than
    # defaultmakefilename. You can add them manually here.
    #add compiler/include/makefile
    #add makefile

A metatarget look like so: ``project.target``. Example:
``AROS.setup``. If nothing is specified, mmake will make the default
target of the first project in the config file. If the project is specified
but no target, mmake will make the default target of this project.


------------------
Coding conventions
------------------

General style
=============

This code is used by many people and therefore you should keep some things
in mind when you submit source code:

+ Keep things simple
+ Keep the source clean
+ Always know what you are doing
+ Tell what you are doing
+ Remember that you write code once but that it is read many times
  by many people


Comments
========

AROS uses some of the comments in the source to generate the documentation.
Therefore it's neccessary to keep a certain format so the tools can find
their information. Other comments are ignored but they should explain what
you thought when you wrote the code. If you really can't think of an
explanation, then don't write the code a second time like this::

    /* This adds 1 to t */
    t++;
    
What we think of is this::

    /* Go on with next element */
    t++;


Function prototypes and headers
===============================

Every function in AROS must have a full ANSI C prototype. Prototypes should
be collected in in one header per file if it is needed by only a few files
(no need to recompile the whole project if you change a function which used
only once), in one header per directory if it's a commonly used function in
that directory or in one header per logical group (ie. one header for all
functions in a library).

The function header (ie. the comment before the function) must be of a
special format because the AutoDocs are generated from it. Here is an
example for it (from <filename>AROS/exec/addhead.c</filename>)::

    /*****************************************************************************

        NAME */
    #include <exec/lists.h>
    #include <clib/exec_protos.h>

	    AROS_LH2I(void, AddHead,

    /*  SYNOPSIS */
            AROS_LHA(struct List *, list, A0),
            AROS_LHA(struct Node *, node, A1),

    /*  LOCATION */
            struct ExecBase *, SysBase, 40, Exec)

    /*  FUNCTION
            Insert Node node as the first node of the list.

        INPUTS
            list - The list to insert the node into
            node - This node is to be inserted

        RESULT
            None.

        NOTES

        EXAMPLE
            struct List * list;
            struct Node * pred;

            // Insert Node at top
            AddHead (list, node);

        BUGS

        SEE ALSO
            NewList(), AddTail(), Insert(), Remove(), RemHead(), RemTail(),
            Enqueue()

        INTERNALS

    ******************************************************************************/
    {

As you can see, comments are used to merge the function prototype and the
header into one.

NAME 
    This field contains all neccessary prototypes to use the function
    from the user point of view and the name of the function in a `AROS_LH#?()`
    macro (Library Header). These macros are used to make the same code work on
    different kind of hardwares. The name of the macro depends on the amount of
    parameters and whether the function needs the library base. `AddHead()`
    does not and therefore an "I" is appended to the macros name. If it need
    the library base (like `AddTask()`), then the "I" is omitted.

    If the function is not part of a shared library and it's arguments must be
    passed in certain registers (eg. callback hooks), you must use
    `AROS_UFH#?()` macros (User Function Header) instead of `AROS_LH#?()`. Append
    the number of arguments to this macro. Since it has never a base, the field
    LOCATION must be omitted and it's not neccessary to append the "I" to the
    macros name. An example for a callback hook `foo()` would be::

        AROS_UFH3(ULONG, foo,
            AROS_UFHA(struct Hook, hook,  A0),
            AROS_UFHA(APTR,        obj,   A2),
            AROS_UFHA(APTR,        param, A1)
        )

    (Note that the registers need not have a particular order).

    If the function is not part of a shared library and it's arguments need not
    be in specific registers, you need no `AROS_#?H#?()` macros::

        /*****************************************************************************

            NAME */
        #include <header.h>

	        int foo (

        /*  SYNOPSIS */
	        int a,
	        int b)

        /*  FUNCTION
	        blahblahblah.
	        ...

        *****************************************************************************/
        
SYNOPSIS 
    This field contains all arguments of the function one by
    one in `AROS_LHA()` macros (Library Header Argument). This macro makes sure
    the respective argument is put in the right CPU register when the function
    is called (if possible and neccessary). The first argument for the macro is
    the type of the parameter followed by the name of the parameter and the
    register the parameter is expected in. Valid names for registers are D0,
    D1, D2 upto D7 and A0 upto A6.

    If the function is not part of a library but the arguments must be passed
    to it in registers, then use `AROS_UFHA()` macros (User Function Header
    Argument) which take the same parameters as the `AROS_LHA()` macros. Don't
    forget the closing parenthese for the `AROS_UFC`.

    If the function is not part of a library and the arguments need not be
    passed in registers, no macros are neccessary.

LOCATION
    This field is neccessary for shared libraries only. It
    contains the last four parameters for the `AROS_LH#?()` macro which are the
    type of the library, the name of the variable, in which the function
    expects the library base, the offset of the function in the jumptable (the
    first vector has 1 and the first vector which may be used by a function is
    5) and the name of the library.

FUNCTION
    This field contains a description of the function.

INPUTS
    This field contains a list of all parameters of the form
    "name - description" or "name, name, name - description". The description
    should tell what the parameter is and what values can be passed to it.
    There is no point in explaining the parameter twice in FUNCTION and here.
    If the function has no parameters, say "None." here.

RESULT
    What the function passes back. This includes return values
    and values passed in arguments of the function. If the function may fail,
    you should explain what it returns on failure and why it might fail.

NOTES
    Important things the user must know or take into account.

EXAMPLE
    This field should contain a small or fully featured
    example.  A good way to present an example is to write some code which tests
    the function, put it into `#ifdef TEST` somewhere in the file and
    put a "See below." here. If you need comments in the code, you have two ways
    for this. If you need only short one-line comments, use C++ style (``//``) 
    comments. Everything from the ``//`` to the end of the line is
    the comment.  If you need more comment, then you can end the comment after the
    `EXAMPLE` and use `#ifdef EXAMPLE` to mask the example out::

            EXAMPLE */
        #ifdef EXAMPLE
	        struct List * list;
	        struct Node * pred;

	        /* Insert Node at top of the list */
	        AddHead (list, node);
        #endif

    Don't use `#ifdef EXAMPLE` if you have a fully featured example (ie. one
    which can be compiled without errors).


BUGS
    This field contains a list of known bugs.

SEE ALSO
    This field contains a list of other functions and documents
    which might be of interest. This includes function which you need to
    initialize, create or destroy an object necessary for this function,
    functions which do similar and opposite things on the main object.

    For example, `SetAttrs()` should contain functions here which can create,
    destroy and manipulate BOOPSI objects but not taglists.

INTERNALS
    This field should contain information for other developers
    which are irrelevant to the user, for example an explanation of the
    algorithm of the function or dependencies.


Formatting
==========

Here is an example of how to format AROS code::

    {
        /* a */
        struct RastPort * rp;
        int               a;

        /* b */
        rp = NULL;
        a  = 1;

        /* c */
        if (a == 1)
            printf ("Init worked\n");

        /* d */
        if
        (
            !(rp = Get_a_pointer_to_the_RastPort
                (
                    some
                    , long
                    , arguments
                )
            )
        ||
            a <= 0
        )
        {
            printf ("Something failed\n");
            return FAIL;
        }

        /* e */
        a = printf ("My RastPort is %p, a=%d\n"
            , rp
            , a
        );

        return OK;
    }


Looks ugly, eh ? :-) Ok, here are the rules:

+ If several lines contain similar code, put similar things below each
  other (see a and b);

+ Put spaces between operands and operators

+ Put braces ``{}``, brackets ``[]`` and parenthese
  ``()`` below each other (d) if there is much code between. Brackets and 
  parenthese may be in one line if the code between is small (c)

+ Indent by 4 Spaces. Two indent levels may be abbreviated by one tab.

  The reasons for this are: 
  
  1. While some editors can use an arbitrary sizes for tabs, it's a bit 
     complicated to tell another editor which
     tab size was used by the one used to write the code. 
  2. Most code in AROS was written this way and your code should look like the
     rest. 
  3. You can print this code on any printer without special
     tools to "fix" the tabs. 4. Most editors have smart tabs which do
     exactly this. If your editor doesn't, write a bug report.

+ If you have a function with many arguments (d, e) you should put the
  parenthese in lines of their own and each argument in one line (d) or put
  the first argument behind the opening parenthese (e) and each following
  argument in a line of its own with the comma in front. The closing
  parenthese is in a line of its own and aligned with the beginning of the
  expression (ie. the a and not the opening parenthese or the
  `printf()`).

+ Use a single blank line to separate logical blocks. Large comments
  should have a blank line before and after them, small comments should be
  put before the code they explain with only one blank line before them.


Writing ROMable code
====================

Code in AROS modules should be written in a way that makes it suitable
for embedding into a ROM, FlashRAM or other kinds read-only
memory. The following coding style rules are meant to make it
possible. Of course they apply to all Kickstart modules and to code
that may be made resident, shared or linked to other modules.

+ ROM modules must have no .data and .bss sections.
  Basically, we need to get rid of all non-const global data.
  The real Amiga Kickstart proves that it's both possible
  and easy to achieve this.

  If you encounter an external variable (static or not) that
  is modified by the code, try to get rid of it or move it into
  the base of the library/device (or in the device node of your
  handler or in the userdata of your class).

+ The above applies to library bases as well. If you are writing
  a library, put the bases of other libraries into your own library
  base structure. Boopsi classes can store library bases in their
  class private data.

+ Try to set the `static` and `const` attributes to all
  your global data. You can also use the `CONST_STRPTR` and
  `CONST_APTR` types defined in <exec/types.h>. Using `static const`
  allows the compiler to move data into the ".text" (AKA code)
  segment.  If you need to pass these globals to another function, try to chenge
  its prototype to use `const` too. Note that, as of OS 3.5, Olaf
  Barthel has finally switched to using `const` in
  <clib/#?_protos.h> headers.

+ **NEVER EVER** touch buffers passed in by the user as an "input"
  parameter. The concept of input parameters is often implicit
  in the function description. For instance, the filename passed
  to `Open()` is clearly an input variable and
  `Open()` must not
  mess with it, even if it is going to fix it back later. Keep
  in mind that the buffer might be in read-only memory or shared
  among several instances of a resident or multithreaded program.

+ Try to avoid host-OS calls such as `malloc()` and
  `free()` if you can do with `AllocMem()` and
  `FreeMem()`. This is because
  the pointer checking debug macros rely on finding the pointer
  within the Exec memory blocks with `TypeOfMem()`.
  
-------
Porting
-------

This file describes how to port AROS to a new kind of hardware.

1. Select an identifying name for your CPU (eg. i386, m68k, hppa, sparc)
   and add "-emul" (eg. i386-emul) if your port is to be running as
   a "sub-OS" or "-native" (eg. m68k-native) if the port will be a
   standalone OS.

2. Select an identifying name for your system (eg. sgi, linux, amiga, etc).

3. Edit "configure" and make it recognize your kind of hardware and adjust
   the numerous variables as your system requires.

   KERNEL
   	The kind of CPU you use (see 1.)
   
   ARCH
   	Name of your system (see 2.)
    
   SYS_CC
   	The name of your C compiler
    
   COMMON_CFLAGS
   	options which should be handed to every call to the
	C compiler (eg. -g -Wall -O0 etc.)
   
   ILDFLAGS
   	The flags you must give to the compiler when linking to
	prevent it to use any standard libraries or startup modules
	(for GCC the options are -nostartfiles -nostdlib -Xlinker -i).
	This is used to create AROS executables. These executables must
	not have any unresolved symbols and all references must be
	filled.
    
   RANLIB
   	contains the name of your ranlib program. If you don't have
	one, specify "true" here (or the name of any other shell command
	which simply ignores all parameters and doesn't return an
	error code).

4. Type "make". It will abort because there is no $(KERNEL) yet, but setup
   some important files and directory trees.

5. Make a copy of i386-emul to $(KERNEL) and convert all assembler sources
   from x86 to your CPU.

6. Populate $(KERNEL)/. It is recommended that you make a copy of i386-emul,
   because that is the most uptodate version of the kernel.

7. Type "make machine". It will compile a programm and run it. The output
   can be used to modify $(KERNEL)/machine.h.

8. Run "make machine.i" in $(KERNEL). It will generate a file "machine.i"
   which you need to compile the assembler files. "machine.i" contains the
   values if numerous system constants (function vector offsets, structure
   field offsets and system flags).

9. Edit all #?.s files in $(KERNEL) and generate the appropriate machine code
   for your CPU. To compile the files, type "make".

10. Go to the main directory and type make. If there any errors, write them
    down, then fix them and continue with step 10.

11. Go to bin/$(ARCH)/AROS and start "arosshell". Now you can type
    some commands (eg. "dir all", "list" or "demowin"). If all works well,
    you get a list of directories and files with "dir all" and "demowin"
    opens a window with some gadgets and renderings with which you can
    play. Typing "Esc" or clicking on "Exit" quits the demo. To stop the
    arosshell, you must press ^C (Ctrl-C) since as a real OS there is
    no way to stop nicely.

