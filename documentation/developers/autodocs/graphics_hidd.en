=============
graphics_hidd
=============

.. This document is automatically generated. Don't edit it!

`Index <index>`_

----------

Classes
-------

+ `IID_HIDD_ColorMap`_
+ `IID_HIDD_Gfx`_
+ `IID_HIDD_BitMap`_
+ `IID_HIDD_GC`_

----------

IID_HIDD_ColorMap
-----------------

========================================== ========================================== ========================================== ========================================== 
`aoHidd_ColorMap_NumEntries`_              `moHidd_ColorMap_GetColor`_                `moHidd_ColorMap_GetPixel`_                `moHidd_ColorMap_SetColors`_               

========================================== ========================================== ========================================== ========================================== 

-----------

aoHidd_ColorMap_NumEntries
==========================

Function
~~~~~~~~
::

     Number of colors in the colormap.



----------

moHidd_ColorMap_GetColor
========================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *o, struct pHidd_ColorMap_GetColor *msg);

     BOOL HIDD_CM_GetColor(OOP_Object *obj, ULONG colorNo, HIDDT_Color *colorReturn);


Inputs
~~~~~~
::

     obj         -
     colorNo     -
     colorReturn -



----------

moHidd_ColorMap_GetPixel
========================

Synopsis
~~~~~~~~
::

     HIDDT_Pixel OOP_DoMethod(OOP_Object *obj, struct pHidd_ColorMap_GetPixel *msg);

     HIDDT_Pixel HIDD_CM_GetPixel(OOP_Object *obj, ULONG pixelNo);


Inputs
~~~~~~
::

     obj     -
     pixelNo -



----------

moHidd_ColorMap_SetColors
=========================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_ColorMap_SetColors *msg);

     BOOL HIDD_CM_SetColors(OOP_Object *obj, HIDDT_Color *colors, ULONG firstColor,
                            ULONG numColors, OOP_Object *pixFmt);


Inputs
~~~~~~
::

     obj        -
     colors     -
     firstColor -
     numColors  -
     pixFmt     -



IID_HIDD_Gfx
------------

========================================== ========================================== ========================================== ========================================== 
`--background--`_                          `--display_modes--`_                       `aoHidd_Gfx_DMPSLevel`_                    `aoHidd_Gfx_IsWindowed`_                   
`aoHidd_Gfx_ModeTags`_                     `aoHidd_Gfx_NoFrameBuffer`_                `aoHidd_Gfx_NumSyncs`_                     `aoHidd_Gfx_PixFmtTags`_                   
`aoHidd_Gfx_SupportsHWCursor`_             `aoHidd_Gfx_SyncTags`_                     `moHidd_Gfx_CheckMode`_                    `moHidd_Gfx_CopyBox`_                      
`moHidd_Gfx_DisposeBitMap`_                `moHidd_Gfx_DisposeGC`_                    `moHidd_Gfx_GetGamma`_                     `moHidd_Gfx_GetMode`_                      
`moHidd_Gfx_GetPixFmt`_                    `moHidd_Gfx_GetSync`_                      `moHidd_Gfx_ModeProperties`_               `moHidd_Gfx_NewBitMap`_                    
`moHidd_Gfx_NewGC`_                        `moHidd_Gfx_NextModeID`_                   `moHidd_Gfx_QueryModeIDs`_                 `moHidd_Gfx_ReleaseModeIDs`_               
`moHidd_Gfx_SetCursorPos`_                 `moHidd_Gfx_SetCursorShape`_               `moHidd_Gfx_SetCursorVisible`_             `moHidd_Gfx_SetGamma`_                     
`moHidd_Gfx_SetMode`_                      `moHidd_Gfx_Show`_                         `moHidd_Gfx_ShowImminentReset`_            `moHidd_Gfx_ShowViewPorts`_                

========================================== ========================================== ========================================== ========================================== 

-----------

--background--
==============

Notes
~~~~~
::

     When working with graphics drivers this is the first object you get.
     It allows you to create BitMap and GC (graphics context)
     object. The class' methods must be overidden by hardware-specific
     subclasses where documented to do so.



----------

--display_modes--
=================

Notes
~~~~~
::

     Each display driver object internally stores a database of supported display mode
     IDs. This database is normally managed by base class, the driver does not need to
     reimplement respective methods.

     A display mode ID in AROS is a 32-bit integer value, the same as on AmigaOS(tm).
     However mode ID layout introduced by Commodore does not fit well for RTG systems.
     In order to overcome its limitations, display ID on AROS may have two forms:

     1. A chipset mode ID. These are standard IDs defined by Commodore. You may find
        their definitions in graphics/modeid.h.

     2. AROS RTG mode ID.

     An RTG mode ID is composed of three parts in the form:

     nnnn xx yy

     nnnn - monitor ID. This number is maintained by system libraries. IDs are
            assigned in the order in which drivers are loaded and display hardware is
            found. Drivers do not have to care about this part, and should normally
            mask it out if they for some reason look at mode ID. In order to
            distinguish between chipset mode IDs and RTG mode IDs, order number starts
            not from zero, reserving some space for C= chipset mode IDs (which appear
            to have order numbers from 0x0000 to 0x000A). Currently RTG monitor IDs
            start from 0x0010, however with time this value may change. So don't rely
            on some particular values in RTG IDs. Use cybergraphics.library/IsCyberModeID()
            function if you want to know for sure if the given mode ID belongs to an
            RTG driver.

       xx - A sync object index in driver's mode database.
       yy - A pixelformat object in driver's mode database.

     Normally the driver does not have to care about mode ID decoding. The mode
     database is maintained by base class. The only useful things for the driver are
     sync and pixelformat objects, from which it's possible to get different
     information about the mode. They can be obtained from the base class using
     HIDD_Gfx_GetMode().

     Note that the driver object by itself does not know its monitor ID. Different
     displays are served by different objects, any of which may belong to any class.
     So all driver methods which return mode IDs will set monitor ID to zero. All
     methods that take mode ID as argument are expected to ignore the monitor ID part
     and do not make any assumptions about its value.



----------

aoHidd_Gfx_DMPSLevel
====================

Function
~~~~~~~~
::

     Gets or sets current DPMS level for driver's display.
     A value can be one of:
         vHidd_Gfx_DPMSLevel_On,
         vHidd_Gfx_DPMSLevel_Standby,
         vHidd_Gfx_DPMSLevel_Suspend,
         vHidd_Gfx_DPMSLevel_Off

     If the driver does not support some state, it's up to the driver what to do.
     Usually it is expected to ignore the request.

     Getting this attribute should return real current state.



----------

aoHidd_Gfx_IsWindowed
=====================

Function
~~~~~~~~
::

     Tells if the display driver is using hosted display in host OS' window.


Notes
~~~~~
::

     At the moment the system does not use this attribute in any way. The attribute
     is considered reserved, its semantics and meaning may change. Applications should
     not use this attribute for now.


Bugs
~~~~
::

     Not all hosted drivers provide this attribute.



----------

aoHidd_Gfx_ModeTags
===================

Function
~~~~~~~~
::

     ...



----------

aoHidd_Gfx_NoFrameBuffer
========================

Function
~~~~~~~~
::

     Tells whether the driver does not need a framebuffer.

     A framebuffer is a special bitmap in a fixed area of video RAM. If the framebuffer
     is used, the driver is expected to copy a new bitmap into it in HIDD_Gfx_Show()
     and optionally copy old bitmap back.

     A framebuffer is needed if the hardware does not have enough VRAM to store many
     bitmaps or does not have capabilities to switch the display between various VRAM
     regions.

     An example of driver using a framebuffer is hosted SDL driver. By design SDL works
     only with single display window, which is considered a framebuffer.


Notes
~~~~~
::

     Provides FALSE if not implemented in the driver.



See also
~~~~~~~~

`moHidd_Gfx_Show <mohidd_gfx_show>`_ 

----------

aoHidd_Gfx_NumSyncs
===================

Function
~~~~~~~~
::

     Gets total number of sync objects in the internal display mode database.



See also
~~~~~~~~

`moHidd_Gfx_GetSync <mohidd_gfx_getsync>`_ 

----------

aoHidd_Gfx_PixFmtTags
=====================

Function
~~~~~~~~
::

     ...



----------

aoHidd_Gfx_SupportsHWCursor
===========================

Function
~~~~~~~~
::

     Tells whether the driver supports hardware mouse pointer sprite.
     
     If the driver provides TRUE value for this attribute, it is expected to implement
     HIDD_Gfx_SetCursorPos(), HIDD_Gfx_SetCursorShape() and HIDD_Gfx_SetCursorVisible()
     methods.

     Mouse pointer counts for one hardware sprite, so if the driver implements also
     HIDD_Gfx_ModeProperties(), it should set NumHWSprites to 1 in order to provide
     valid information about display modes.
     
     The driver must implement this attribute if it implements HIDD_Gfx_ModeProperties().
     Otherwise it will provide false information in graphics.library/GetDisplayInfoData().
     Base class can determine NumHWSprites based on this attribute value but not vice
     versa.


Notes
~~~~~
::

     Default implementation in the base class returns FALSE. This causes the system to
     use software sprite emulation.



See also
~~~~~~~~

`moHidd_Gfx_ModeProperties <mohidd_gfx_modeproperties>`_ 

----------

aoHidd_Gfx_SyncTags
===================

Function
~~~~~~~~
::

     ...



----------

moHidd_Gfx_CheckMode
====================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_CheckMode *msg);

     BOOL HIDD_Gfx_CheckMode(OOP_Object *gfxHidd, HIDDT_ModeID modeID,
                             OOP_Object *sync, OOP_Object *pixFmt);


Function
~~~~~~~~
::

     Check if given display mode is supported by the driver.

     Normally any resolution (sync) can be used together with any pixelformat. However
     on some hardware there may be exceptions from this rule. In such a case this
     method should be implemented, and check should be performed.

     The information provided by this method is used in order to exclude unsupported
     modes from the database

     Default implementation in the base class just returns TRUE for all supplied values.

     Note that this method can not be used in order to chech that the given mode is
     really present in the database and it really refers to the given sync and
     pixelformat objects. Use HIDD_Gfx_GetMode() for mode ID validation.


Inputs
~~~~~~
::

     gfxHidd - A display driver object
     modeID  - A display mode ID
     sync    - A pointer to a sync object associated with this mode
     pixFmt  - A pointer to a pixelformat object associated with this mode


Result
~~~~~~
::

     TRUE if this mode is supported and FALSE if it's not.


Bugs
~~~~
::

     Currently base class does not call this method after driver object creation.
     This needs to be fixed.



See also
~~~~~~~~

`moHidd_Gfx_GetMode <mohidd_gfx_getmode>`_ 

----------

moHidd_Gfx_CopyBox
==================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_CopyBox *msg);

     VOID HIDD_Gfx_CopyBox(OOP_Object *gfxHidd, OOP_Object *src, WORD srcX, WORD srcY,
                           OOP_Object *dest, WORD destX, WORD destY, UWORD width, UWORD height, 
                           OOP_Object *gc);


Function
~~~~~~~~
::

     Perform rectangle copy (blit) operation from one bitmap to another.
 
     Given bitmaps may belong to different display drivers. The driver may attempt to
     use hardware for acceleration (if availible), and if it's impossible, pass the
     operation on to the base class.
 
     Always check class of the supplied bitmap before attempting to look at its
     private data.
 
     A GC is used in order to specify raster operation performed between the source
     and destination according to its aHidd_GC_DrawMode attribute value.


Inputs
~~~~~~
::

     gfxHidd - a display driver object that you are going to use for copying
     src     - a pointer to source bitmap object
     srcX    - an X coordinate of the source rectangle
     srcY    - an Y coordinate of the source rectangle
     dest    - a pointer to destination bitmap object
     destX   - an X coordinate of the destination rectangle
     destY   - an Y coordinate of the destination rectangle
     width   - width of the rectangle to copy
     height  - height of the rectangle to copy
     gc      - graphics context holding draw mode on the destination


Result
~~~~~~
::

     None.


Notes
~~~~~
::

     You must specify valid coordinates (non-negative and inside the actual bitmap
     area), no checks are done.
     
     It is valid to specify two overlapped areas of the same bitmap as source
     and destination.



----------

moHidd_Gfx_DisposeBitMap
========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_DisposeBitMap *msg);

     VOID HIDD_Gfx_DisposeBitMap(OOP_Object *gfxHidd, OOP_Object *bitMap);


Function
~~~~~~~~
::

     Deletes a bitmap object previously created by HIDD_Gfx_NewBitMap().

     Subclasses do not have to override this method
     unless they allocate anything additional to a bitmap object in
     their HIDD_Gfx_NewBitMap() implementation.


Inputs
~~~~~~
::

     gfxHidd - A driver object which was used for creating a bitmap.
     bitMap  - Pointer to a bitmap object to delete.


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`moHidd_Gfx_NewBitMap <mohidd_gfx_newbitmap>`_ 

----------

moHidd_Gfx_DisposeGC
====================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_DisposeGC *msg);

     VOID HIDD_Gfx_DisposeGC(OOP_Object *gfxHidd, OOP_Object *gc)


Function
~~~~~~~~
::

     Deletes a GC (Graphics Context) object previously created
     by HIDD_Gfx_NewGC().

     Subclasses do not have to override this method
     unless they allocate anything additional to a gc object in
     their HIDD_Gfx_NewGC() implementation.


Inputs
~~~~~~
::

     gfxHidd - A driver object which was used for creating a GC.
     gc      - Pointer to gc object to delete.


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`moHidd_Gfx_NewGC <mohidd_gfx_newgc>`_ 

----------

moHidd_Gfx_GetGamma
===================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_Gamma *msg);

     BOOL HIDD_Gfx_GetGamma(OOP_Object *gfxHidd, UBYTE *Red, UBYTE *Green, UBYTE *Blue);


Function
~~~~~~~~
::

     Get current gamma table for the display.

     A gamma table consists of three 256-byte tables: one for red component, one for
     green and one for blue.

     A user should supply three pointers to preallocated 256-byte tables which will
     be filled in. Any ot these pointers may have NULL value, in this case the
     respective component will be ignored.


Inputs
~~~~~~
::

     gfxHidd - A display driver object
     Red     - A pointer to a 256-byte array for red component or NULL
     Green   - A pointer to a 256-byte array for green component or NULL
     Blue    - A pointer to a 256-byte array for blue component or NULL


Result
~~~~~~
::

     FALSE if the driver doesn't support gamma correction, otherwise TRUE


Notes
~~~~~
::

     This method can be used just to query if the driver supports gamma correction.
     Just set Red, Green and Blue to NULL for this.



See also
~~~~~~~~

`moHidd_Gfx_SetGamma <mohidd_gfx_setgamma>`_ 

----------

moHidd_Gfx_GetMode
==================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_GetMode *msg);

     BOOL HIDD_Gfx_GetMode(OOP_Object *gfxHidd, HIDDT_ModeID modeID,
                           OOP_Object **syncPtr, OOP_Object **pixFmtPtr);


Function
~~~~~~~~
::

     Get sync and pixelformat objects for a particular display ModeID.


Inputs
~~~~~~
::

     gfxHidd   - pointer to a driver object which this ModeID belongs to
     syncPtr   - pointer to a storage where sync object pointer will be placed
     pixFmtPtr - pointer to a storage where pixelformat object pointer will be placed


Result
~~~~~~
::

     TRUE upon success, FALSE in case of failure (e.g. given mode does not exist in
     driver's internal database). If the function returns FALSE, sync and pixelformat
     pointers will be set to NULL.


Notes
~~~~~
::

     Every display mode is associated with some sync and pixelformat object. If the
     method returns TRUE, object pointers are guaranteed to be valid.



See also
~~~~~~~~

`moHidd_Gfx_NextModeID <mohidd_gfx_nextmodeid>`_ 

----------

moHidd_Gfx_GetPixFmt
====================

Synopsis
~~~~~~~~
::

     OOP_Object *OOP_DoMethod(OOP_Object *o, struct pHidd_Gfx_GetPixFmt *msg); 

     OOP_Object *HIDD_Gfx_GetPixFmt(OOP_Object *gfxHidd, HIDDT_StdPixFmt pixFmt);


Function
~~~~~~~~
::

     Get a standard pixelformat descriptor from internal pixelformats database.


Inputs
~~~~~~
::

     gfxHidd - A display driver object
     pixFmt  - An index of pixelformat (one of vHIDD_StdPixFmt_... values)


Result
~~~~~~
::

     A pointer to a pixelformat object or NULL if lookup failed


Notes
~~~~~
::

     Pixelformat objects are stored in a global system-wide database. They are not
     linked with a particular driver in any way and completely sharable between all
     drivers.



----------

moHidd_Gfx_GetSync
==================

Synopsis
~~~~~~~~
::

     OOP_Object *OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_GetSync *msg);

     OOP_Object *HIDD_Gfx_GetSync(OOP_Object *gfxHidd, ULONG num);


Function
~~~~~~~~
::

     Get a sync object from internal display mode database by index


Inputs
~~~~~~
::

     gfxHidd - A display driver object to query
     num     - An index of pixelformat starting from 0


Result
~~~~~~
::

     A pointer to a sync object or NULL if there's no sync with such index



----------

moHidd_Gfx_ModeProperties
=========================

Synopsis
~~~~~~~~
::

     ULONG OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_ModeProperties *msg);

     ULONG HIDD_Gfx_ModeProperties(OOP_Object *gfxHidd, HIDDT_ModeID modeID,
                                   struct HIDD_ModeProperties *props, ULONG propsLen);


Function
~~~~~~~~
::

     Obtain an information about the video mode.

     Video mode description structure may grow in future, so be careful and always check
     propsLen parameter value. A system may ask you for less data than you can provide.
     Always return an actual value. Do not just zero out fields you don't know about,
     this is not expected to be backwards compatible.


Inputs
~~~~~~
::

     gfxHidd  - a pointer to a display driver object whose display mode you want to query
     modeID   - a mode ID to query
     props    - a pointer to a storage area where HIDD_ModeProperties structure will be put
     propsLen - A length of the supplied buffer in bytes.


Result
~~~~~~
::

     An actual length of obtained structure


Notes
~~~~~
::

     Returned data must reflect only real hardware capabilities. For example, do not
     count emulated sprites. The system takes care about emulated features itself.



See also
~~~~~~~~

`aoHidd_Gfx_SupportsHWCursor <aohidd_gfx_supportshwcursor>`_ 

----------

moHidd_Gfx_NewBitMap
====================

Synopsis
~~~~~~~~
::

     OOP_Object *OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_NewBitMap *msg);

     OOP_Object *HIDD_Gfx_NewBitMap(OOP_Object *gfxHidd, struct TagItem *tagList);


Function
~~~~~~~~
::

     Create a bitmap object.

     One graphics driver represents at least one displayable bitmap class.
     Additionally it may represent more classes (for example some old drivers use
     separate class for nondisplayable bitmaps).

     These classes are private to the driver. In order to be able to use them
     bitmap objects are never created directly. Instead they are created using
     HIDD_Gfx_NewBitMap() call. An implementation of this method in the driver
     should examine bitmap attributes supplied and make a decision if the bitmap
     should be created using driver's own class or one of system classes.

     A typical implementation should pay attention to the following bitmap attributes:
 
     aHIDD_BitMap_ModeID - If this attribute is supplied, the bitmap needs to be
                           either displayable by this driver, or be a friend of
                           displayable bitmap. A friend bitmap usually repeats the
                           internal layout of its friend so that the driver may
                           perform blitting operations quickly.

     aHIDD_BitMap_Displayable - If this attribute is supplied, the bitmap NEEDS to be
                                displayable by this driver. Usually this means that
                                bitmap object will contain video hardware state
                                information. This attribute will always be accompanied
                                by aHIDD_BitMap_ModeID.

     aHIDD_BitMap_FrameBuffer - The bitmap needs to be a framebuffer bitmap. A
                                framebuffer bitmap is necessary for some kinds of
                                hardware which have a small fixed amount of video
                                RAM which can hold only one screen at a time. Setting
                                this attribute also requires to set also a valid ModeID.

     aHIDD_BitMap_Friend - If there's no ModeID supplied, you may wish to check class
                           of friend bitmap. This can be useful if your driver uses
                           different classes for displayable and non-displayable bitmaps.
                           By default base class will pick up friend's class and use it
                           for new bitmap if nothing is specified, here you may override
                           this behavior.

     If your driver wants to specify own class for the bitmap being created,
     it should prepend an aHIDD_BitMap_ClassPtr attribute to the supplied taglist
     and pass it to base class. It's not allowed to create bitmap objects directly
     since they need some more extra information which is added by the base class!

     This method must be implemented by your subclass. aHIDD_BitMap_ClassPtr or
     aHIDD_BitMap_ClassID must be provided to the base class for a displayable bitmap!


Inputs
~~~~~~
::

     gfxHidd - A graphics driver object with which the GC will perform
               the rendering operations.

     tagList - A list of bitmap attributes. See hidd.graphics.bitmap class
               documentation for their description.


Result
~~~~~~
::

     gc - pointer to the newly created GC, ready for use for rendering
          operations.
 


See also
~~~~~~~~

`moHidd_Gfx_DisposeBitMap <mohidd_gfx_disposebitmap>`_ 

----------

moHidd_Gfx_NewGC
================

Synopsis
~~~~~~~~
::

     OOP_Object *OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_NewGC *msg);

     OOP_Object *HIDD_Gfx_NewGC(OOP_Object *gfxHidd, struct TagItem *tagList);


Function
~~~~~~~~
::

     Create a GC (gfx context) object that may be used for rendering
     into a bitmap.


Inputs
~~~~~~
::

     gfxHidd - A graphics driver object with which the GC will perform
               the rendering operations.
     tagList - A list of GC attributes. See hidd.graphics.gc class
               documentation for their description.


Result
~~~~~~
::

     gc - pointer to the newly created GC, ready for use for rendering
          operations.


Notes
~~~~~
::

     A GC object is just a data storage. You may create a subclass of GC if
     you wish to, however there's usually no need to. Additionally, this may
     be not future-proof (since GC subclasses can not be interchanged between
     different drivers. Please avoid using custom GCs.


Bugs
~~~~
::

     At the moment subclassing GCs is not supported because some parts of
     the operating system create GC objects directly. It is unclear whether
     subclassing GCs is actually needed.



See also
~~~~~~~~

`moHidd_Gfx_DisposeGC <mohidd_gfx_disposegc>`_ 

----------

moHidd_Gfx_NextModeID
=====================

Synopsis
~~~~~~~~
::

     HIDDT_ModeID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_NextModeID *msg);

     HIDDT_ModeID HIDD_Gfx_NextModeID(OOP_Object *gfxHidd, HIDDT_ModeID modeID,
                                      OOP_Object **syncPtr, OOP_Object **pixFmtPtr);


Function
~~~~~~~~
::

     Iterate driver's internal display mode database.


Inputs
~~~~~~
::

     gfxHidd   - A driver object to query
     modeID    - A previous mode ID or vHidd_ModeID_Invalid for start of the iteration
     syncPtr   - A pointer to a storage where pointer to sync object will be placed
     pixFmtPtr - A pointer to a storage where pointer to pixelformat object will be placed


Result
~~~~~~
::

     Next available mode ID or vHidd_ModeID_Invalid if there are no more display modes.
     If the function returns vHidd_ModeID_Invalid, sync and pixelformat pointers will
     be set to NULL.



See also
~~~~~~~~

`moHidd_Gfx_GetMode <mohidd_gfx_getmode>`_ 

----------

moHidd_Gfx_QueryModeIDs
=======================

Synopsis
~~~~~~~~
::

     HIDDT_ModeID *OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_QueryModeIDs *msg);

     HIDDT_ModeID *HIDD_Gfx_QueryModeIDs(OOP_Object *gfxHidd, struct TagItem *queryTags);


Function
~~~~~~~~
::

     Obtain a table of all supported display mode IDs
 
     The returned address points to an array of HIDDT_ModeID containing all ModeIDs
     supported by this driver. The array is terminated with vHidd_ModeID_Invalid.


Inputs
~~~~~~
::

     gfxHidd   - A driver object which to query.
     querytags - An optional taglist containing query options. Can be NULL.
                 The following tags are supported:

                 tHidd_GfxMode_MinWidth  (ULONG) - A minimum width of modes you are
                                                   interested in
                 tHidd_GfxMode_MaxWidth  (ULONG) - A maximum width of modes you are
                                                   interested in
                 tHidd_GfxMode_MinHeight (ULONG) - A minimum height of modes you are
                                                   interested in
                 tHidd_GfxMode_MaxHeight (ULONG) - A maximum height of modes you are
                                                   interested in
                 tHidd_GfxMode_PixFmts   (HIDDT_StdPifXmt *) - A pointer to an array
                     of standard pixelformat indexes. If supplied, only mode IDs whose
                     pixelformat numbers match any of given ones will be returned.


Result
~~~~~~
::

     A pointer to an array of ModeIDs or NULL in case of failure



See also
~~~~~~~~

`moHidd_Gfx_ReleaseModeIDs <mohidd_gfx_releasemodeids>`_ `moHidd_Gfx_NextModeID <mohidd_gfx_nextmodeid>`_ 

----------

moHidd_Gfx_ReleaseModeIDs
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_ReleaseModeIDs *msg);

     VOID HIDD_Gfx_ReleaseModeIDs(OOP_Object *gfxHidd, HIDDT_ModeID *modeIDs);


Function
~~~~~~~~
::

     Free array of display mode IDs returned by HIDD_Gfx_QueryModeIDs()


Inputs
~~~~~~
::

     gfxHidd - A driver object used to obtain the array
     modeIDs - A pointer to an array


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`moHidd_Gfx_QueryModeIDs <mohidd_gfx_querymodeids>`_ 

----------

moHidd_Gfx_SetCursorPos
=======================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_SetCursorPos *msg);

     BOOL HIDD_Gfx_SetCursorPos(OOP_Object *gfxHidd, LONG x, LONG y);


Function
~~~~~~~~
::

     Set current mouse pointer position.

     This is a real position on top-left image corner relative to top-left corner of
     the physical display. Neither logical screen origin nor hotspot are taken into
     account here.

     The default implementation in the base class does nothing and just returns TRUE.
     If a software pointer emulation is used, this method will never be called.


Inputs
~~~~~~
::

     gfxHidd - a display driver object, on whose display you wish to position the pointer
     x       - An x coordinate of the pointer (relative to the physical screen origin)
     y       - An y coordinate of the pointer (relative to the physical screen origin)


Result
~~~~~~
::

     Always TRUE. Reserved for future, do not use it.


Notes
~~~~~
::

     This method is called by graphics.library/MoveSprite() which has no return value.
     However, for historical reasons, this method has a return value. Drivers should
     always return TRUE in order to ensure future compatibility.



See also
~~~~~~~~

`moHidd_Gfx_SetCursorShape <mohidd_gfx_setcursorshape>`_ `moHidd_Gfx_SetCursorVisible <mohidd_gfx_setcursorvisible>`_ `graphics.library/MoveSprite() <./graphics#movesprite>`_ 

----------

moHidd_Gfx_SetCursorShape
=========================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_SetCursorShape *msg);

     BOOL HIDD_Gfx_SetCursorShape(OOP_Object *gfxHidd, OOP_Object *shape,
                                  LONG xoffset, LONG yoffset);


Function
~~~~~~~~
::

     Set mouse pointer shape.

     A pointer image is contained in the specified bitmap object. The bitmap object
     may contain a colormap if the system wants to specify own colors for the pointer.
     The supplied colormap will also contain alpha channel values.

     It is up to driver what to do if, for example, alpha channel is not supported by
     the hardware. Or if given bitmap type is not supported (for example truecolor
     bitmap on LUT-only hardware). It is expected that the driver converts bitmap
     data to a more appropriate form in such a case.

     A hotspot is given as an offset from the actual hotspot to the top-left corner
     of the pointer image. It is generally needed only for hosted display drivers
     which utilize host's support for mouse pointer.

     The default implementation in the base class just does nothing. A software mouse
     pointer is implemented in a special layer calles fakegfx.hidd inside
     graphics.library. If a software pointer emulation is used, this method will
     never be called.


Inputs
~~~~~~
::

     gfxHidd - a display driver object, for whose display you wish to change the pointer
     shape   - a pointer to a bitmap object, containing pointer bitmap
     xoffset - a horizontal hotspot offset
     yoffset - a vertical hotspot offset


Result
~~~~~~
::

     TRUE on success, FALSE on failure



See also
~~~~~~~~

`moHidd_Gfx_SetCursorPos <mohidd_gfx_setcursorpos>`_ `moHidd_Gfx_SetCursorVisible <mohidd_gfx_setcursorvisible>`_ 

----------

moHidd_Gfx_SetCursorVisible
===========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_SetCursorVisible *msg);

     VOID HIDD_Gfx_SetCursorVisible(OOP_Object *gfxHidd, BOOL visible);


Function
~~~~~~~~
::

     Control mouse pointer visiblity.

     The default implementation in the base class does nothing. If a software pointer
     emulation is used, this method will never be called.


Inputs
~~~~~~
::

     gfxHidd - a display driver object, on whose display you wish to turn pointer or on off
     visible - TRUE to enable pointer display, FALSE to disable it


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`moHidd_Gfx_SetCursorPos <mohidd_gfx_setcursorpos>`_ `moHidd_Gfx_SetCursorVisible <mohidd_gfx_setcursorvisible>`_ 

----------

moHidd_Gfx_SetGamma
===================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_Gamma *msg);

     BOOL HIDD_Gfx_SetGamma(OOP_Object *gfxHidd, UBYTE *Red, UBYTE *Green, UBYTE *Blue);


Function
~~~~~~~~
::

     Set current gamma table for the display.

     A gamma table consists of three 256-byte tables: one for red component, one for
     green and one for blue.

     A user should supply three pointers to 256-byte tables from which gamma values
     will be picked up. Any ot these pointers may have NULL value, in this case the
     respective component will be ignored.


Inputs
~~~~~~
::

     gfxHidd - A display driver object
     Red     - A pointer to a 256-byte array for red component or NULL
     Green   - A pointer to a 256-byte array for green component or NULL
     Blue    - A pointer to a 256-byte array for blue component or NULL


Result
~~~~~~
::

     FALSE if the driver doesn't support gamma correction, otherwise TRUE


Notes
~~~~~
::

     This method can be used just to query if the driver supports gamma correction.
     Just set Red, Green and Blue to NULL for this.



See also
~~~~~~~~

`moHidd_Gfx_GetGamma <mohidd_gfx_getgamma>`_ 

----------

moHidd_Gfx_SetMode
==================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_SetMode *msg);

     BOOL HIDD_Gfx_SetMode(OOP_Object *gfxHidd, OOP_Object *sync);


Function
~~~~~~~~
::

     Update display mode according to changed sync object


Inputs
~~~~~~
::

     gfxHidd - A display driver to operate on
     sync    - A modified sync object pointer


Result
~~~~~~
::

     TRUE if everything went OK and FALSE in case of some error


Notes
~~~~~
::

     This method is used to inform the driver that some external program has changed
     sync data and wants to update the display if needed. It's up to the implementation to
     check that current display is really using this sync (frontmost screen uses this mode).



----------

moHidd_Gfx_Show
===============

Synopsis
~~~~~~~~
::

     OOP_Object *OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_Show *msg);

     OOP_Object *HIDD_Gfx_Show(OOP_Object *gfxHidd, OOP_Object *bitMap, ULONG flags);


Function
~~~~~~~~
::

     Change currently displayed bitmap on the screen.

     The bitmap object supplied must have been created with aHidd_BitMap_Displayable
     attribute set to TRUE.

     The function's behavior differs a lot depending on whether the driver uses a
     framebuffer or video hardware is able to switch screens itself.

     If the driver uses framebuffer bitmap, it is supposed to copy the supplied bitmap
     into the framebuffer and return a framebuffer pointer. It also can be asked to
     copy back old framebuffer contents into previous bitmap object. It is driver's
     job to keep track of which bitmap object was displayed last time. This is what
     default implementation does. Note that it is very basic, and even does not support
     changing display resolution. It's not recommended to rely on it in production
     drivers (unless your video hardware supports only one mode).

     If the driver does not use a framebuffer, it is supposed to reprogram the hardware
     here to display an appropriate region of video RAM. Do not call the base class
     in this case, its implementation relies on framebuffer existance and will always
     return NULL which indicates an error.

     It is valid to get NULL value in bitMap parameter. This means that there is
     nothing to display and the screen needs to be blanked out. It is valid for
     non-framebuffer-based driver to return NULL as a reply then. In all other cases
     NULL return value means an error.

     Please avoid returning errors at all. graphics.library/LoadView() has no error
     indication. An error during showing a bitmap would leave the display in
     unpredictable state.

     If the driver does not use a framebuffer, consider using HIDD_Gfx_ShowViewPorts().
     It's more straightforward, flexible and offers support for screen composition.


Inputs
~~~~~~
::

     gfxHidd - a display driver object, whose display you wish to change.
     bitMap  - a pointer to a bitmap object which needs to be shown or NULL.
     flags   - currently only one flag is defined:

     fHidd_Gfx_Show_CopyBack - Copy back the image data from framebuffer bitmap
                               to old displayed bitmap. Used only if the driver
                               needs a framebuffer.


Result
~~~~~~
::

     A pointer to a currently displayed bitmap object or NULL (read FUNCTION paragraph for
     detailed description)



See also
~~~~~~~~

`moHidd_Gfx_ShowViewPorts <mohidd_gfx_showviewports>`_ `graphics.library/LoadView() <./graphics#loadview>`_ 

----------

moHidd_Gfx_ShowImminentReset
============================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, OOP_Msg msg);


Function
~~~~~~~~
::

     Indicate upcoming machine reset

     The system calls this method when the machine is about to perform a warm reboot.
     The driver is expected to blank the screen and reset the hardware to some known
     idle state. There is no need to preserve an old hardware state and/or current
     bitmap's data.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     None.


Notes
~~~~~
::

     This method is obsolete, support for it will go away in future. New drivers
     should use exec reset callbacks in order to get an upcoming reboot notifications.
     The reset code can be executed on an unstable system suffering from crash, so
     using an OOP method here is not a very good idea.



----------

moHidd_Gfx_ShowViewPorts
========================

Synopsis
~~~~~~~~
::

     ULONG OOP_DoMethod(OOP_Object *obj, struct pHidd_Gfx_ShowViewPorts *msg);

     ULONG HIDD_Gfx_ShowViewPorts(OOP_Object *gfxHidd, struct HIDD_ViewPortData *data);


Function
~~~~~~~~
::

     Show one or more bitmaps on the screen.

     It is completely up to the driver how to implement this function. The driver may
     may or may not support hardware-assisted screens composition. Bitmaps are sorted
     in the list in descending z-order. The driver is expected to put at least frontmost
     bitmap on display.

     It is valid to get NULL pointer as data parameter. This means that there's
     nothing to show and the screen should go blank.

     Bitmaps display offsets are stored in their aHidd_BitMap_XOffset and
     aHidd_BitMap_YOffset attributes. This function is not expected to modify their
     values somehow. They are assumed to be preserved between calls unless changed
     explicitly by the system.

     If you implement this method, you don't have to implement HIDD_Gfx_Show() because
     it will never be called.

     Note that there is no more error indication - the driver is expected to be
     error-free here.


Inputs
~~~~~~
::

     gfxHidd - a display driver object, whose display you wish to change.
     data    - a singly linked list of bitmap objects to show


Result
~~~~~~
::

     TRUE if this method is supported by the driver, FALSE otherwise



See also
~~~~~~~~

`moHidd_Gfx_Show <mohidd_gfx_show>`_ 

IID_HIDD_BitMap
---------------

========================================== ========================================== ========================================== ========================================== 
`aoHidd_BitMap_Align`_                     `aoHidd_BitMap_BytesPerRow`_               `aoHidd_BitMap_ClassID`_                   `aoHidd_BitMap_ClassPtr`_                  
`aoHidd_BitMap_ColorMap`_                  `aoHidd_BitMap_Displayable`_               `aoHidd_BitMap_FrameBuffer`_               `aoHidd_BitMap_Friend`_                    
`aoHidd_BitMap_GfxHidd`_                   `aoHidd_BitMap_Height`_                    `aoHidd_BitMap_IsLinearMem`_               `aoHidd_BitMap_LeftEdge`_                  
`aoHidd_BitMap_ModeID`_                    `aoHidd_BitMap_PixFmt`_                    `aoHidd_BitMap_PixFmtTags`_                `aoHidd_BitMap_StdPixFmt`_                 
`aoHidd_BitMap_TopEdge`_                   `aoHidd_BitMap_Visible`_                   `aoHidd_BitMap_Width`_                     `moHidd_BitMap_BitMapScale`_               
`moHidd_BitMap_BlitColorExpansion`_        `moHidd_BitMap_BytesPerLine`_              `moHidd_BitMap_Clear`_                     `moHidd_BitMap_DrawEllipse`_               
`moHidd_BitMap_DrawLine`_                  `moHidd_BitMap_DrawPixel`_                 `moHidd_BitMap_DrawPolygon`_               `moHidd_BitMap_DrawRect`_                  
`moHidd_BitMap_DrawText`_                  `moHidd_BitMap_FillEllipse`_               `moHidd_BitMap_FillPolygon`_               `moHidd_BitMap_FillRect`_                  
`moHidd_BitMap_FillSpan`_                  `moHidd_BitMap_FillText`_                  `moHidd_BitMap_GetImage`_                  `moHidd_BitMap_GetImageLUT`_               
`moHidd_BitMap_MapColor`_                  `moHidd_BitMap_ObtainDirectAccess`_        `moHidd_BitMap_PutAlphaImage`_             `moHidd_BitMap_PutAlphaTemplate`_          
`moHidd_BitMap_PutImage`_                  `moHidd_BitMap_PutImageLUT`_               `moHidd_BitMap_PutPattern`_                `moHidd_BitMap_PutTemplate`_               
`moHidd_BitMap_PutTranspImageLUT`_         `moHidd_BitMap_ReleaseDirectAccess`_       `moHidd_BitMap_SetColorMap`_               `moHidd_BitMap_SetColors`_                 
`moHidd_BitMap_SetRGBConversionFunction`_  `moHidd_BitMap_UnmapPixel`_                `moHidd_BitMap_UpdateRect`_                
========================================== ========================================== ========================================== ========================================== 

-----------

aoHidd_BitMap_Align
===================

Function
~~~~~~~~
::

     Number of pixels to align bitmap data width to



----------

aoHidd_BitMap_BytesPerRow
=========================

Function
~~~~~~~~
::

     Number of bytes in a row 



----------

aoHidd_BitMap_ClassID
=====================

Function
~~~~~~~~
::

     Only used by subclasses of the gfx hidd



----------

aoHidd_BitMap_ClassPtr
======================

Function
~~~~~~~~
::

     Only used by subclasses of the gfx hidd.



----------

aoHidd_BitMap_ColorMap
======================

Function
~~~~~~~~
::

     Colormap of the bitmap



----------

aoHidd_BitMap_Displayable
=========================

Function
~~~~~~~~
::

     Bitmap is displayable (default: FALSE)



----------

aoHidd_BitMap_FrameBuffer
=========================

Function
~~~~~~~~
::

     Allocate framebuffer



----------

aoHidd_BitMap_Friend
====================

Function
~~~~~~~~
::

     Friend bitmap. The bitmap will be allocated so that it
     is optimized for blitting to this bitmap.



----------

aoHidd_BitMap_GfxHidd
=====================

Function
~~~~~~~~
::

     Pointer to the gfxhidd object this bitmap was created with.



----------

aoHidd_BitMap_Height
====================

Function
~~~~~~~~
::

     Bitmap height



----------

aoHidd_BitMap_IsLinearMem
=========================

Function
~~~~~~~~
::

     Is the bitmap memory contigous?



----------

aoHidd_BitMap_LeftEdge
======================

Function
~~~~~~~~
::

     Left edge position of the bitmap



----------

aoHidd_BitMap_ModeID
====================

Function
~~~~~~~~
::

     Must be passed on initialization of aHidd_BitMap_Displayable=TRUE bitmaps.
     May also be used with non-displayable bitmaps.



----------

aoHidd_BitMap_PixFmt
====================

Function
~~~~~~~~
::

     This is complete pixmft of a bitmap.



----------

aoHidd_BitMap_PixFmtTags
========================

Function
~~~~~~~~
::

     Only used by subclasses of BitMap class.



----------

aoHidd_BitMap_StdPixFmt
=======================

Function
~~~~~~~~
::

     What stdpixel format the bitmap should have.
     This is a shortcut to create a bitmap with a std pixelformat.



----------

aoHidd_BitMap_TopEdge
=====================

Function
~~~~~~~~
::

     Top edge position of the bitmap.



----------

aoHidd_BitMap_Visible
=====================

Function
~~~~~~~~
::

     Check if a bitmap is visible



----------

aoHidd_BitMap_Width
===================

Function
~~~~~~~~
::

     Bitmap with



----------

moHidd_BitMap_BitMapScale
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_BitMapScale * msg);

     VOID HIDD_BM_BitMapScale(OOP_Object *obj, OOP_Object *src, OOP_Object *dest,
                              struct BitScaleArgs * bsa, OOP_Object *gc);


Inputs
~~~~~~
::

     obj  -
     src  -
     dest -
     bsa  -
     gc   -



----------

moHidd_BitMap_BlitColorExpansion
================================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_BlitColorExpansion *msg);

     VOID HIDD_BM_BlitColorExpansion (OOP_Object *obj, OOP_Object *gc, OOP_Object *srcBitMap,
                                      WORD srcX, WORD srcY, WORD destX, WORD destY,
                                      UWORD width, UWORD height);


Inputs
~~~~~~
::

     obj       -
     gc        -
     srcBitMap -
     srcX      -
     srcY      -
     destX     -
     destY     -
     width     -
     height    -



----------

moHidd_BitMap_BytesPerLine
==========================

Synopsis
~~~~~~~~
::

     ULONG OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_BytesPerLine *msg);

     ULONG HIDD_BM_BytesPerLine(OOP_Object *obj, HIDDT_StdPixFmt pixFmt, ULONG width);


Inputs
~~~~~~
::

     obj    -
     pixFmt -
     width  -



----------

moHidd_BitMap_Clear
===================

Synopsis
~~~~~~~~
::

     OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_Clear *msg);

     VOID HIDD_BM_Clear (OOP_Object *obj, OOP_Object *gc);


Function
~~~~~~~~
::

     Sets all pixels of the drawing area to the background color.
     This command is available in quick and normal mode and behaves
     similar in both modes.


Inputs
~~~~~~
::

     obj -
     gc  -



----------

moHidd_BitMap_DrawEllipse
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawEllipse *msg);

     VOID HIDD_BM_DrawEllipse (OOP_Object *obj, OOP_Object *gc, WORD x, WORD y,
                               WORD rx, WORD ry);


Function
~~~~~~~~
::

     Draws a hollow ellipse from the center point (x/y) with the radii
     rx and ry in the specified bitmap.
     The function does not clip the ellipse against the drawing area.


Inputs
~~~~~~
::

     obj   -
     gc    -
     x,y   - center point in hidd units
     rx,ry - ry and ry radius in hidd units


Bugs
~~~~
::

     Because of overflow the current code do not work with big
     values of rx and ry.



----------

moHidd_BitMap_DrawLine
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawPixel *msg);

     VOID HIDD_BM_DrawLine(OOP_Object *obj, OOP_Object *gc, WORD x1, WORD y1,
                           WORD x2, WORD y2);


Function
~~~~~~~~
::

     Draws a line from (x1,y1) to (x2,y2) in the specified gc.
     The function does not clip the line against the drawing area.


Inputs
~~~~~~
::

     obj   -
     gc    -
     x1,y1 - start point of the line in hidd units
     x2,y2 - end point of the line in hidd units



----------

moHidd_BitMap_DrawPixel
=======================

Synopsis
~~~~~~~~
::

     ULONG OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawPixel *msg);

     ULONG HIDD_BM_DrawPixel(OOP_Object *obj, OOP_Object *gc, WORD x, WORD y);


Function
~~~~~~~~
::

     Changes the pixel at (x,y). The color of the pixel depends on the
     attributes of gc, eg. colors, drawmode, colormask etc.
     This function does not the coordinates.


Inputs
~~~~~~
::

     obj  -
     gc   -
     x, y - coordinates of the pixel in hidd units



See also
~~~~~~~~

`moHidd_Gfx_SetAttributes <mohidd_gfx_setattributes>`_ 

----------

moHidd_BitMap_DrawPolygon
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawPolygon *msg);

     VOID HIDD_BM_DrawPolygon (OOP_Object *obj, OOP_Object *gc, UWORD n, WORD *coords);


Function
~~~~~~~~
::

     Draws a hollow polygon from the list of coordinates in coords[].
     The function does not clip the polygon against the drawing area.


Inputs
~~~~~~
::

     obj    -
     gc     -
     n      - number of coordinate pairs
     coords - array of n (x, y) coordinates in hidd units



----------

moHidd_BitMap_DrawRect
======================

Synopsis
~~~~~~~~
::

     OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawRect *msg);

     VOID HIDD_BM_DrawRect (OOP_Object *obj, OOP_Object *gc, WORD minX, WORD minY,
                       WORD maxX, WORD maxY);


Function
~~~~~~~~
::

     Draws a hollow rectangle from. minX and minY specifies the upper
     left corner of the rectangle. minY and maxY specifies the lower
     right corner of the rectangle.
     The function does not clip the rectangle against the drawing area.


Inputs
~~~~~~
::

     obj        -
     gc         -
     minX, minY - upper left corner of the rectangle in hidd units
     maxX, maxY - lower right corner of the rectangle in hidd units



----------

moHidd_BitMap_DrawText
======================

Synopsis
~~~~~~~~
::

     OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawText *msg);

     VOID HIDD_BM_DrawText (OOP_Object *obj, OOP_Object *gc, WORD x, WORD y,
                            STRPTR text, UWORD length);


Function
~~~~~~~~
::

     Draws the first length characters of text at (x, y).
     The function does not clip the text against the drawing area.


Inputs
~~~~~~
::

     obj    -
     gc     -
     x, y   - Position to start drawing in hidd units. The x
              coordinate is relativ to the left side of the
              first character.
              The y coordinate is relative to the baseline of the font.
     text   - Pointer to a Latin 1 string
     length - Number of characters to draw



----------

moHidd_BitMap_FillEllipse
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawEllipse *msg);

     VOID HIDD_BM_FillEllipse (OOP_Object *obj, OOP_Object *gc, WORD x, WORD y,
                               WORD ry, WORD rx);


Function
~~~~~~~~
::

     Draws a solid ellipse from the center point (x/y) with the radii
     rx and ry in the specified bitmap.
     The function does not clip the ellipse against the drawing area.


Inputs
~~~~~~
::

     obj   -
     gc    -
     x,y   - center point in hidd units
     rx,ry - ry and ry radius in hidd units


Example
~~~~~~~
::


     Because of overflow the current code do not work with big
     values of rx and ry.



----------

moHidd_BitMap_FillPolygon
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawPolygon *msg);

     VOID HIDD_BM_FillPolygon (OOP_Object *obj, OOP_Object *gc, UWORD n, WORD *coords);


Function
~~~~~~~~
::

     Draws a solid polygon from the list of coordinates in coords[].
     If the last point of the polygon is not equal to the first point
     then the function closes the polygon.

     The function does not clip the polygon against the drawing area.


Inputs
~~~~~~
::

     obj    -
     gc     -
     n      - number of coordinate pairs
     coords - array of n (x, y) coordinates in hidd units



----------

moHidd_BitMap_FillRect
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawRect *msg);

     VOID HIDD_BM_FillRect (OOP_Object *obj, OOP_Object *gc, WORD minX, WORD minY,
                            WORD maxX, WORD maxY);


Function
~~~~~~~~
::


     Draws a solid rectangle. minX and minY specifies the upper
     left corner of the rectangle. minY and maxY specifies the lower
     right corner of the rectangle.
     The function does not clip the rectangle against the drawing area.


Inputs
~~~~~~
::

     obj        -
     gc         -
     minX, minY - upper left corner of the rectangle in hidd units
     maxX, maxY - lower right corner of the rectangle in hidd units



----------

moHidd_BitMap_FillSpan
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawText *msg);


Function
~~~~~~~~
::

     Draws a solid from a shape description in the specified bitmap. This
     command is available in quick and normal mode. In normal mode,
     the spans are clipped against the drawing area.



----------

moHidd_BitMap_FillText
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_DrawText *msg);

     VOID HIDD_BM_FillText (OOP_Object *obj, OOP_Object *gc, WORD x, WORD y,
                            STRPTR text, UWORD length);


Function
~~~~~~~~
::

     Fills the area of the text with the background color
     and draws the first length characters of text at (x, y).
     The function does not clip the text against the drawing area.


Inputs
~~~~~~
::

     obj    -
     gc     -
     x, y   - Position to start drawing in hidd units. The x
              coordinate is relativ to the left side of the
              first character.
              The y coordinate is relative to the baseline of the font.
     text   - Pointer to a Latin 1 string
     length - Number of characters to draw



----------

moHidd_BitMap_GetImage
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_GetImage *msg);

     VOID HIDD_BM_GetImage (OOP_Object *obj, UBYTE *pixels, ULONG modulo, WORD x, WORD y,
                            WORD width, WORD height, HIDDT_StdPixFmt pixFmt);


Inputs
~~~~~~
::

     obj    -
     pixels -
     modulo -
     x, y   -
     width  -
     height -
     pixFmt -



----------

moHidd_BitMap_GetImageLUT
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_GetImageLUT *msg);

     VOID HIDD_BM_GetImageLUT (OOP_Object *obj, UBYTE *pixels, ULONG modulo, WORD x, WORD y,
                               WORD width, WORD height, HIDDT_PixelLUT *pixlut);


Inputs
~~~~~~
::

     obj    -
     pixels -
     modulo -
     x, y   -
     width  -
     height -
     pixlut -



----------

moHidd_BitMap_MapColor
======================

Synopsis
~~~~~~~~
::

     HIDDT_Pixel OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_MapColor *msg);

     HIDDT_Pixel HIDD_BM_MapColor(OOP_Object *obj, HIDDT_Color *color);


Inputs
~~~~~~
::

     obj   -
     color -



----------

moHidd_BitMap_ObtainDirectAccess
================================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_ObtainDirectAccess *msg);

     BOOL HIDD_BM_ObtainDirectAccess(OOP_Object *obj, UBYTE **addressReturn,
                                     ULONG *widthReturn, ULONG *heightReturn,
                                     ULONG *bankSizeReturn, ULONG *memSizeReturn);


Inputs
~~~~~~
::

     obj            -
     addressReturn  -
     widthReturn    -
     heightReturn   -
     bankSizeReturn -
     memSizeReturn  -


Result
~~~~~~
::

     BOOL



----------

moHidd_BitMap_PutAlphaImage
===========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_PutAlphaImage *msg);

     VOID HIDD_BM_PutAlphaImage (OOP_Object *obj, OOP_Object *gc, UBYTE *pixels, ULONG modulo,
                                 WORD x, WORD y, WORD width, WORD height);


Inputs
~~~~~~
::

     obj    -
     gc     -
     pixels -
     modulo -
     x, y   -
     width  -
     height -



----------

moHidd_BitMap_PutAlphaTemplate
==============================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_PutAlphaTemplate *msg);

     VOID HIDD_BM_PutAlphaTemplate (OOP_Object *obj, OOP_Object *gc, UBYTE *alpha, ULONG modulo,
                                    WORD x, WORD y, WORD width, WORD height, BOOL invertalpha);


Inputs
~~~~~~
::

     obj         -
     gc          -
     alpha       -
     modulo      -
     x, y        -
     width       -
     height      -
     invertalpha -



----------

moHidd_BitMap_PutImage
======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_PutImage *msg);

     VOID HIDD_BM_PutImage (OOP_Object *obj, OOP_Object *gc, UBYTE *pixels, ULONG modulo,
                            WORD x, WORD y, WORD width, WORD height, HIDDT_StdPixFmt pixFmt);


Inputs
~~~~~~
::

     obj    -
     gc     -
     pixels -
     modulo -
     x, y   -
     width  -
     height -
     pixFmt -



----------

moHidd_BitMap_PutImageLUT
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *o, struct pHidd_BitMap_PutImageLUT *msg);

     VOID HIDD_BM_PutImageLUT (OOP_Object *obj, OOP_Object *gc, UBYTE *pixels, ULONG modulo,
                               WORD x, WORD y, WORD width, WORD height, HIDDT_PixelLUT *pixlut);


Inputs
~~~~~~
::

     obj    -
     gc     -
     pixels -
     modulo -
     x, y   -
     width  -
     height -
     pixlut -



----------

moHidd_BitMap_PutPattern
========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *o, struct pHidd_BitMap_PutPattern *msg);

     VOID HIDD_BM_PutPattern(OOP_Object *obj, OOP_Object *gc, UBYTE *pattern,
                             WORD patternsrcx, WORD patternsrcy, WORD patternheight, WORD patterndepth,
                             HIDDT_PixelLUT *patternlut, BOOL invertpattern, UBYTE *mask,
                             ULONG maskmodulo, WORD masksrcx, WORD x, WORD y,
                             WORD width, WORD height);


Inputs
~~~~~~
::

     obj           -
     gc            -
     pattern       -
     patternsrcx   -
     patternsrcy   -
     patternheight -
     patterndepth  -
     patternlut    -
     invertpattern -
     mask          -
     maskmodulo    -
     masksrcx      -
     x, y          -
     width         -
     height        -



----------

moHidd_BitMap_PutTemplate
=========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_PutTemplate *msg);

     VOID HIDD_BM_PutTemplate (OOP_Object *obj, OOP_Object *gc, UBYTE *template, ULONG modulo,
                               WORD srcx, WORD x, WORD y, WORD width, WORD height, BOOL inverttemplate);


Inputs
~~~~~~
::

     obj            -
     gc             -
     template       -
     modulo         -
     srcx           -
     x, y           -
     width          -
     height         -
     inverttemplate -



----------

moHidd_BitMap_PutTranspImageLUT
===============================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_PutTranspImageLUT *msg);

     VOID HIDD_BM_PutTranspImageLUT (OOP_Object *obj, OOP_Object *gc, UBYTE *pixels,
                                     ULONG modulo, WORD x, WORD y, WORD width, WORD height,
                                     HIDDT_PixelLUT *pixlut, UBYTE transparent);


Inputs
~~~~~~
::

     obj         -
     gc          -
     pixels      -
     modulo      -
     x, y        -
     width       -
     height      -
     pixlut      -
     transparent -



----------

moHidd_BitMap_ReleaseDirectAccess
=================================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_ReleaseDirectAccess *msg);

     VOID HIDD_BM_ReleaseDirectAccess(OOP_Object *obj);


Inputs
~~~~~~
::

     obj -



----------

moHidd_BitMap_SetColorMap
=========================

Synopsis
~~~~~~~~
::

     OOP_Object * OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_SetColorMap *msg);

     OOP_Object * HIDD_BM_SetColorMap(OOP_Object *obj, OOP_Object *colorMap);


Inputs
~~~~~~
::

     obj      -
     colorMap -



----------

moHidd_BitMap_SetColors
=======================

Synopsis
~~~~~~~~
::

     BOOL OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_SetColors *msg);

     BOOL HIDD_BM_SetColors (OOP_Object *obj, HIDDT_Color *colors,
                             ULONG firstColor, ULONG numColors);


Inputs
~~~~~~
::

     obj        -
     colors     -
     firstColor -
     numColors  -



----------

moHidd_BitMap_SetRGBConversionFunction
======================================

Synopsis
~~~~~~~~
::

     HIDDT_RGBConversionFunction
     OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_SetRGBConversionFunction *msg);

     HIDDT_RGBConversionFunction
     HIDD_BM_SetRGBConversionFunction(OOP_Object *obj, HIDDT_StdPixFmt srcPixFmt,
                                      HIDDT_StdPixFmt dstPixFmt, 
                                      HIDDT_RGBConversionFunction function);



----------

moHidd_BitMap_UnmapPixel
========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_UnmapPixel *msg);

     VOID HIDD_BM_UnmapPixel(OOP_Object *obj, HIDDT_Pixel pixel, HIDDT_Color *color);


Inputs
~~~~~~
::

     obj   -
     pixel -
     color -



----------

moHidd_BitMap_UpdateRect
========================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_BitMap_UpdateRect *msg);

     VOID HIDD_BM_UpdateRect(OOP_Object *obj, WORD x, WORD y, WORD width, WORD height);


Inputs
~~~~~~
::

     obj    -
     x, y   -
     width  -
     height -



IID_HIDD_GC
-----------

========================================== ========================================== ========================================== ========================================== 
`aoHidd_GC_Background`_                    `aoHidd_GC_BitMap`_                        `aoHidd_GC_ColorExpansionMode`_            `aoHidd_GC_ColorMask`_                     
`aoHidd_GC_DrawMode`_                      `aoHidd_GC_Font`_                          `aoHidd_GC_Foreground`_                    `aoHidd_GC_LinePattern`_                   
`aoHidd_GC_LinePatternCnt`_                `aoHidd_GC_PlaneMask`_                     `aoHidd_GC_UserData`_                      `moHidd_GC_SetClipRect`_                   
`moHidd_GC_UnsetClipRect`_                 
========================================== ========================================== ========================================== ========================================== 

-----------

aoHidd_GC_Background
====================

Function
~~~~~~~~
::

     Background color



----------

aoHidd_GC_BitMap
================

Function
~~~~~~~~
::

     Bitmap which this gc uses.



----------

aoHidd_GC_ColorExpansionMode
============================

Function
~~~~~~~~
::

     Mode for color expansion
 


----------

aoHidd_GC_ColorMask
===================

Function
~~~~~~~~
::

     Prevents some color bits from changing.



----------

aoHidd_GC_DrawMode
==================

Function
~~~~~~~~
::

     Draw mode



----------

aoHidd_GC_Font
==============

Function
~~~~~~~~
::

     Current font



----------

aoHidd_GC_Foreground
====================

Function
~~~~~~~~
::

     Foreground color



----------

aoHidd_GC_LinePattern
=====================

Function
~~~~~~~~
::

     Pattern for line drawing
 


----------

aoHidd_GC_LinePatternCnt
========================

Function
~~~~~~~~
::

     Pattern start bit for line drawing.
 


----------

aoHidd_GC_PlaneMask
===================

Function
~~~~~~~~
::

     Shape bitmap 



----------

aoHidd_GC_UserData
==================

Function
~~~~~~~~
::

     User data



----------

moHidd_GC_SetClipRect
=====================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_GC_SetClipRect *msg);

     VOID HIDD_GC_SetClipRect(OOP_Object *obj, LONG x1, LONG y1, LONG x2, LONG y2);


Inputs
~~~~~~
::

     obj -
     x1  -
     y1  -
     x2  -
     y2  -



----------

moHidd_GC_UnsetClipRect
=======================

Synopsis
~~~~~~~~
::

     VOID OOP_DoMethod(OOP_Object *obj, struct pHidd_GC_UnsetClipRect *msg);

     VOID HIDD_GC_UnsetClipRect(OOP_Object *obj);


Inputs
~~~~~~
::

     obj -



