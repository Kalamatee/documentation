======
kernel
======

.. This document is automatically generated. Don't edit it!

`Index <index>`_

----------

======================================= ======================================= ======================================= ======================================= 
`KrnAddExceptionHandler()`_             `KrnAddIRQHandler()`_                   `KrnAllocPages()`_                      `KrnBug()`_                             
`KrnCause()`_                           `KrnCli()`_                             `KrnCreateContext()`_                   `KrnDecodeLocationA()`_                 
`KrnDeleteContext()`_                   `KrnDispatch()`_                        `KrnFreePages()`_                       `KrnGetBootInfo()`_                     
`KrnGetScheduler()`_                    `KrnGetSystemAttr()`_                   `KrnInitMemory()`_                      `KrnIsSuper()`_                         
`KrnMapGlobal()`_                       `KrnMayGetChar()`_                      `KrnPutChar()`_                         `KrnRegisterModule()`_                  
`KrnRemExceptionHandler()`_             `KrnRemIRQHandler()`_                   `KrnSchedule()`_                        `KrnSetProtection()`_                   
`KrnSetScheduler()`_                    `KrnSetSystemAttr()`_                   `KrnStatMemoryA()`_                     `KrnSti()`_                             
`KrnSwitch()`_                          `KrnUnmapGlobal()`_                     `KrnUnregisterModule()`_                `KrnVirtualToPhysical()`_               

======================================= ======================================= ======================================= ======================================= 

-----------

KrnAddExceptionHandler()
========================

Synopsis
~~~~~~~~
::

 void * KrnAddExceptionHandler(
          uint8_t num,
          exhandler_t * handler,
          void * handlerData,
          void * handlerData2 );

Function
~~~~~~~~
::

     Add a raw CPU exception handler to the chain of handlers.


Inputs
~~~~~~
::

     num          - CPU-specific exception number
     handler      - Pointer to a handler function
     handlerData,
     handlerData2 - User-defined data which is passed to the
                    handler.
     
       Handler function uses a C calling convention and must be
       declared as follows:
       
       int ExceptionHandler(void *ctx, void *handlerData, void *handlerData2)
         
       handlerData and handlerData2 will be values passed to the
       KrnAddExceptionHandler() function. ctx is a CPU context handle.
       Consider this parameter private and reserved for now.

       Exception handler should return nonzero value if it processes the
       exception and wants to continue program execution. Otherwise it should
       return zero. If all exception handlers in the chain return zero, the
       exception will be passed on to exec.library trap handler pointed to
       by tc_TrapCode field of task structure.


Result
~~~~~~
::

     An opaque handle that can be used for handler removal or NULL in case
     of failure (like unsupported exception number).


Notes
~~~~~
::

     The specification of this function is preliminary and subject to change.
     Consider it private for now.



See also
~~~~~~~~

`KrnRemExceptionHandler()`_ 

----------

KrnAddIRQHandler()
==================

Synopsis
~~~~~~~~
::

 void * KrnAddIRQHandler(
          uint8_t irq,
          irqhandler_t * handler,
          void * handlerData,
          void * handlerData2 );

Function
~~~~~~~~
::

     Add a raw hardware IRQ handler to the chain of handlers.


Inputs
~~~~~~
::

     num          - hardware-specific IRQ number
     handler      - Pointer to a handler function
     handlerData,
     handlerData2 - User-defined data which is passed to the
                    handler.
     
       Handler function uses a C calling convention and must be
       declared as follows:

       void IRQHandler(void *handlerData, void *handlerData2)

       handlerData and handlerData2 will be values passed to the
       KrnAddExceptionHandler() function.

       There is no return code for the IRQ handler.


Result
~~~~~~
::

     An opaque handle that can be used for handler removal or NULL in case
     of failure (like unsupported exception number).



See also
~~~~~~~~

`KrnRemIRQHandler()`_ 

----------

KrnAllocPages()
===============

Synopsis
~~~~~~~~
::

 void * KrnAllocPages(
          void * addr,
          uintptr_t length,
          uint32_t flags );

Function
~~~~~~~~
::

     Allocate physical memory pages


Inputs
~~~~~~
::

     addr   - Starting address of region which must be included in the
              allocated region or NULL for the system to choose the
              starting address. Normally you will supply NULL here.
     length - Length of the memory region to allocate
     flags  - Flags describing type of needed memory. These are the same
              flags as passed to exec.library/AllocMem().


Result
~~~~~~
::

     Real starting address of the allocated region.


Notes
~~~~~
::

     Since this allocator is page-based, length will always be round up
     to system's memory page size. The same applies to starting address
     (if specified), it will be rounded down to page boundary.

     This function works only on systems with MMU support. Without MMU
     it will always return NULL.



See also
~~~~~~~~

`KrnFreePages()`_ 

----------

KrnBug()
========

Synopsis
~~~~~~~~
::

 int KrnBug(
          const char * format,
          va_list args );

Function
~~~~~~~~
::

     Output a formatted string to low-level debug output stream.

     The function supports the same set of formatting specifiers
     as standard C printf() function.


Inputs
~~~~~~
::

     format - A format string
     args   - A list of arguments


Result
~~~~~~
::

     Number of succesfully printed characters



----------

KrnCause()
==========

Synopsis
~~~~~~~~
::

 void KrnCause();


----------

KrnCli()
========

Synopsis
~~~~~~~~
::

 void KrnCli();

Function
~~~~~~~~
::

     Instantly disable interrupts.


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     None


Notes
~~~~~
::

     This is low level function, it does not have nesting count
     and state tracking mechanism. It operates directly on the CPU.
     Normal applications should consider using exec.library/Disable().



See also
~~~~~~~~

`KrnSti()`_ 

----------

KrnCreateContext()
==================

Synopsis
~~~~~~~~
::

 void * KrnCreateContext();

Function
~~~~~~~~
::

     Allocate and initialize CPU context storage area.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     A pointer to a CPU context storage area.


Notes
~~~~~
::

     CPU context storage is considered private and accessible
     only from within supevisor mode.



See also
~~~~~~~~

`KrnDeleteContext()`_ 

----------

KrnDecodeLocationA()
====================

Synopsis
~~~~~~~~
::

 int KrnDecodeLocationA(
          void * addr,
          struct TagItem * tags );
 
 int KrnDecodeLocation(
          void * addr,
          TAG tag, ... );

Function
~~~~~~~~
::

     Locate the given address in the list of registered modules and return
     information about it.


Inputs
~~~~~~
::

     addr - An address to resolve
     tags - An optional taglist. ti_Tag can be one of the following tags and
            ti_Data is always a pointer to a storage of specified type.
            Resulting values will be placed into specified locations if the
            function succeeds.

         KDL_ModuleName     (char *) - Module name
         KDL_SegmentName    (char *) - Segment name. Can be NULL if there were
                                       no segment names provided for the module.
         KDL_SegmentPointer (BPTR)   - DOS pointer to the corresponding segment.
                                       Note that it will be different from
                                       KDL_SegmentStart value
         
         KDL_SegmentNumber  (unsigned int) - Order number of the segment in the
                                             module
         KDL_SegmentStart   (void *) - Start address of actual segment contents
                                       in memory.
         KDL_SegmentEnd     (void *) - End address of actual segment contents
                                       in memory.
     
         The following tags may return NULL values if there was no corresponding
         information provided for the module:

         KDL_SymbolName     (char *) - Symbol name (function or variable name)
         KDL_SymbolStart    (void *) - Start address of contents described by this
                                       symbol.
         KDL_SymbolEnd      (void *) - End address of contents described by this
                                       symbol.


Result
~~~~~~
::

     Zero if lookup failed and no corresponding module found, nonzero
     otherwise.


Notes
~~~~~
::

     If the function fails values pointed to by taglist will not be changed.



----------

KrnDeleteContext()
==================

Synopsis
~~~~~~~~
::

 void KrnDeleteContext(
          void * context );

Function
~~~~~~~~
::

     Free CPU context storage area


Inputs
~~~~~~
::

     context - a pointer to a CPU context storage previously allocated using
               KrnCreateContext()


Result
~~~~~~
::

     None.



See also
~~~~~~~~

`KrnCreateContext()`_ 

----------

KrnDispatch()
=============

Synopsis
~~~~~~~~
::

 void KrnDispatch();


----------

KrnFreePages()
==============

Synopsis
~~~~~~~~
::

 void KrnFreePages(
          void * addr,
          uintptr_t length );

Notes
~~~~~
::

     This function works only on systems with MMU support.



----------

KrnGetBootInfo()
================

Synopsis
~~~~~~~~
::

 struct TagItem * KrnGetBootInfo();


----------

KrnGetScheduler()
=================

Synopsis
~~~~~~~~
::

 KRN_SchedType KrnGetScheduler();


----------

KrnGetSystemAttr()
==================

Synopsis
~~~~~~~~
::

 intptr_t KrnGetSystemAttr(
          uint32_t id );

Function
~~~~~~~~
::

     Get value of internal system attributes.
     Currently defined attributes are:

       KATTR_Architecture [.G] (char *)        - Name of architecture the kernel built for.
       KATTR_VBlankEnable [SG] (unsigned char) - Enable or disable exec VBlank emulation by kernel.resource.
                                                 This can be needed for timer.device implementations for
                                                 systems with only one timer available. In this case timer.device
                                                 should shut off kernel's VBlank emulation before taking over the
                                                 timer and drive exec VBlank itself.
       KATTR_TimerIRQ     [.G] (int)           - Number of high precision periodic timer IRQ to be used by timer.device.
                                                 Needed if kernel.resource provides a timer which runs at frequency
                                                 which is multiple of VBlank. Generic timer.device may use this IRQ
                                                 for improved accuracy. Frequency of this timer is specified in
                                                 SysBase->ex_EClockFrequency.


Inputs
~~~~~~
::

     id - ID of the attribute to get


Result
~~~~~~
::

     Value of the attribute


Notes
~~~~~
::

     These attributes (except KATTR_Architecture) are of very limited use for end user software.
     They are valid only in certain system states. For example KATTR_TimerPeriod goes meaningless
     if timer.device has taken over the system timer. These attributes are provided for system
     components themselves, so it's better to stay away from them.



See also
~~~~~~~~

`KrnSetSystemAttr()`_ 

----------

KrnInitMemory()
===============

Synopsis
~~~~~~~~
::

 void KrnInitMemory(
          struct MemHeader * mh );

Function
~~~~~~~~
::

     Initialize kernel memory management on a given memory region


Inputs
~~~~~~
::

     mh - Address of a filled in structure describing the region.


Result
~~~~~~
::

     None.



----------

KrnIsSuper()
============

Synopsis
~~~~~~~~
::

 int KrnIsSuper();

Function
~~~~~~~~
::

     Determine if the caller is running in supervisor mode


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     Nonzero for supervisor mode, zero for user mode


Notes
~~~~~
::

     Callers should only test the return value against zero.
     Nonzero values may actually be different, since they
     may carry some private implementation-dependent information
     (like CPU privilege level, for example).



----------

KrnMapGlobal()
==============

Synopsis
~~~~~~~~
::

 int KrnMapGlobal(
          void * virtual,
          void * physical,
          uint32_t length,
          KRN_MapAttr flags );


----------

KrnMayGetChar()
===============

Synopsis
~~~~~~~~
::

 int KrnMayGetChar();

Function
~~~~~~~~
::

     Read a single character from low-level debug input stream


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     An ASCII code of the character or -1 if there's no character
     available


Notes
~~~~~
::

     This function never waits. If there is no character available on
     the stream it just returns with -1



----------

KrnPutChar()
============

Synopsis
~~~~~~~~
::

 void KrnPutChar(
          char c );

Function
~~~~~~~~
::

     Output a single character to low-level debug output stream


Inputs
~~~~~~
::

     c - A character to output


Result
~~~~~~
::

     None



----------

KrnRegisterModule()
===================

Synopsis
~~~~~~~~
::

 void KrnRegisterModule(
          const char * name,
          BPTR segList,
          ULONG debugType,
          APTR debugInfo );

Function
~~~~~~~~
::

     Add information about the loaded executable module to the
     debug information database


Inputs
~~~~~~
::

     name      - Module name
     segList   - DOS segment list for the module
     debugType - Type of supplied debug information. The only currently
                 supported type is DEBUG_ELF.
     debugInfo - Debug information data. For DEBUG_ELF type this should be
                 a pointer to struct ELF_DebugInfo, filled in as follows:
                   eh - a pointer to ELF file header with int_shnum and
                        int_shstrndx fields filled in.
                   sh - a pointer to an array of ELF section headers.


Result
~~~~~~
::

     None



----------

KrnRemExceptionHandler()
========================

Synopsis
~~~~~~~~
::

 void KrnRemExceptionHandler(
          void * handle );

Function
~~~~~~~~
::

     Remove previously installed CPU exception handler


Inputs
~~~~~~
::

     handle - an opaque handler returned by KrnAddExceptionHandler()
              function


Result
~~~~~~
::

     None



----------

KrnRemIRQHandler()
==================

Synopsis
~~~~~~~~
::

 void KrnRemIRQHandler(
          void * handle );

Function
~~~~~~~~
::

     Remove previously installed hardware IRQ handler


Inputs
~~~~~~
::

     handle - an opaque handler returned by KrnAddIRQHandler()
              function


Result
~~~~~~
::

     None



----------

KrnSchedule()
=============

Synopsis
~~~~~~~~
::

 void KrnSchedule();


----------

KrnSetProtection()
==================

Synopsis
~~~~~~~~
::

 void KrnSetProtection(
          void * address,
          uint32_t length,
          KRN_MapAttr flags );


----------

KrnSetScheduler()
=================

Synopsis
~~~~~~~~
::

 void KrnSetScheduler(
          KRN_SchedType sched );


----------

KrnSetSystemAttr()
==================

Synopsis
~~~~~~~~
::

 int KrnSetSystemAttr(
          uint32_t id,
          intptr_t val );

Function
~~~~~~~~
::

     Set values of internal system attributes


Inputs
~~~~~~
::

     id  - ID of the attribute to set. See KrnGetAttr() description for the
           list of attributes and their meaning.
     val - New value of the attribute


Result
~~~~~~
::

     Zero for success and nonzero for failure (unknown or read-only attribute or
     bad value).


Notes
~~~~~
::

     Kernel attributes control various aspects of kernel's low-level functions.
     The exact semantics of each attribute may vary from system to system.
     Not all systems support all attributes.

     Please do not alter these attributes from within user software, this will
     not do any good things. This function is provided mainly for use by
     other system components which exactly know what they do.



See also
~~~~~~~~

`KrnGetSystemAttr()`_ 

----------

KrnStatMemoryA()
================

Synopsis
~~~~~~~~
::

 ULONG KrnStatMemoryA(
          ULONG flags,
          struct TagItem * query );
 
 ULONG KrnStatMemory(
          ULONG flags,
          TAG tag, ... );

Function
~~~~~~~~
::

     Get various statistics about memory usage


Inputs
~~~~~~
::

     query - An array of TagItems containing query specification. Each
             TagItem consists of tag ID and a pointer to a value of
             specified type which will contain the result of the query.

             Available tag IDs are:

             KMS_Free          (IPTR)  - Get amount of free memory in bytes
             KMS_Total         (IPTR)  - Get total amount of memory in bytes
             KMS_LargestAlloc  (IPTR)  - Get size of the largest allocated chunk in bytes
             KMS_SmallestAlloc (IPTR)  - Get size of the smallest allocated chunk in bytes
             KMS_LargestFree   (IPTR)  - Get size of the largest free chunk in bytes
             KMS_SmallestFree  (IPTR)  - Get size of the smallest free chunk in bytes
             KMS_NumAlloc      (IPTR)  - Get number of allocated chunks
             KMS_NumFree       (IPTR)  - Get number of free chunks
             KMS_PageSize      (ULONG) - Get memory page size

     flags - Flags which specify physical properties of the memory to query.
             These are the same flags as passed to exec.library/AllocMem().


Result
~~~~~~
::

     TRUE if the function worked, FALSE if MMU is not up and running on the system.
     If the function returns FALSE, values will stay uninitialized.


Notes
~~~~~
::

     For all unknown tag IDs result values will be set to 0.



----------

KrnSti()
========

Synopsis
~~~~~~~~
::

 void KrnSti();

Function
~~~~~~~~
::

     Instantly enable interrupts.


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     None


Notes
~~~~~
::

     This is low level function, it does not have nesting count
     and state tracking mechanism. It operates directly on the CPU.
     Normal applications should consider using exec.library/Enable().



See also
~~~~~~~~

`KrnCli()`_ 

----------

KrnSwitch()
===========

Synopsis
~~~~~~~~
::

 void KrnSwitch();


----------

KrnUnmapGlobal()
================

Synopsis
~~~~~~~~
::

 int KrnUnmapGlobal(
          void * virtual,
          uint32_t length );


----------

KrnUnregisterModule()
=====================

Synopsis
~~~~~~~~
::

 void KrnUnregisterModule(
          BPTR segList );

Function
~~~~~~~~
::

     Remove previously registered module from the debug information database


Inputs
~~~~~~
::

     segList - DOS segment list for the module to remove


Result
~~~~~~
::

     None


Notes
~~~~~
::

     The function correctly supports partial removal of the module
     (when an existing seglist is broken and only a part of the module
     is unloaded).



----------

KrnVirtualToPhysical()
======================

Synopsis
~~~~~~~~
::

 void * KrnVirtualToPhysical(
          void * virtual );


