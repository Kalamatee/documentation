======
kernel
======

.. This document is automatically generated. Don't edit it!

`Index <index>`_

----------

======================================= ======================================= ======================================= ======================================= 
`KrnAddExceptionHandler()`_             `KrnAddIRQHandler()`_                   `KrnAllocPages()`_                      `KrnBug()`_                             
`KrnCause()`_                           `KrnCli()`_                             `KrnCreateContext()`_                   `KrnDecodeLocationA()`_                 
`KrnDeleteContext()`_                   `KrnDispatch()`_                        `KrnFreePages()`_                       `KrnGetBootInfo()`_                     
`KrnGetScheduler()`_                    `KrnIsSuper()`_                         `KrnMapGlobal()`_                       `KrnMayGetChar()`_                      
`KrnPutChar()`_                         `KrnRegisterModule()`_                  `KrnRemExceptionHandler()`_             `KrnRemIRQHandler()`_                   
`KrnSchedule()`_                        `KrnSetProtection()`_                   `KrnSetScheduler()`_                    `KrnSti()`_                             
`KrnSwitch()`_                          `KrnUnmapGlobal()`_                     `KrnUnregisterModule()`_                `KrnVirtualToPhysical()`_               

======================================= ======================================= ======================================= ======================================= 

-----------

KrnAddExceptionHandler()
========================

Synopsis
~~~~~~~~
::

 void * KrnAddExceptionHandler(
          uint8_t num,
          exhandler_t * handler,
          void * handlerData,
          void * handlerData2 );

Function
~~~~~~~~
::

     Add a raw CPU exception handler to the chain of handlers.


Inputs
~~~~~~
::

     num          - CPU-specific exception number
     handler      - Pointer to a handler function
     handlerData,
     handlerData2 - User-defined data which is passed to the
                    handler.
     
       Handler function uses a C calling convention and must be
       declared as follows:
       
       int ExceptionHandler(void *ctx, void *handlerData, void *handlerData2)
         
       handlerData and handlerData2 will be values passed to the
       KrnAddExceptionHandler() function. ctx is a CPU context handle.
       Consider this parameter private and reserved for now.

       Exception handler should return nonzero value if it processes the
       exception and wants to continue program execution. Otherwise it should
       return zero. If all exception handlers in the chain return zero, the
       exception will be passed on to exec.library trap handler pointed to
       by tc_TrapCode field of task structure.


Result
~~~~~~
::

     An opaque handle that can be used for handler removal or NULL in case
     of failure (like unsupported exception number).


Notes
~~~~~
::

     The specification of this function is preliminary and subject to change.
     Consider it private for now.



See also
~~~~~~~~

`KrnRemExceptionHandler()`_ 

----------

KrnAddIRQHandler()
==================

Synopsis
~~~~~~~~
::

 void * KrnAddIRQHandler(
          uint8_t irq,
          irqhandler_t * handler,
          void * handlerData,
          void * handlerData2 );

Function
~~~~~~~~
::

     Add a raw hardware IRQ handler to the chain of handlers.


Inputs
~~~~~~
::

     num          - hardware-specific IRQ number
     handler      - Pointer to a handler function
     handlerData,
     handlerData2 - User-defined data which is passed to the
                    handler.
     
       Handler function uses a C calling convention and must be
       declared as follows:

       void IRQHandler(void *handlerData, void *handlerData2)

       handlerData and handlerData2 will be values passed to the
       KrnAddExceptionHandler() function.

       There is no return code for the IRQ handler.


Result
~~~~~~
::

     An opaque handle that can be used for handler removal or NULL in case
     of failure (like unsupported exception number).



See also
~~~~~~~~

`KrnRemIRQHandler()`_ 

----------

KrnAllocPages()
===============

Synopsis
~~~~~~~~
::

 void * KrnAllocPages(
          uint32_t length );


----------

KrnBug()
========

Synopsis
~~~~~~~~
::

 int KrnBug(
          const char * format,
          va_list args );

Function
~~~~~~~~
::

     Output a formatted string to low-level debug output stream.

     The function supports the same set of formatting specifiers
     as standard C printf() function.


Inputs
~~~~~~
::

     format - A format string
     args   - A list of arguments


Result
~~~~~~
::

     Number of succesfully printed characters



----------

KrnCause()
==========

Synopsis
~~~~~~~~
::

 void KrnCause();


----------

KrnCli()
========

Synopsis
~~~~~~~~
::

 void KrnCli();

Function
~~~~~~~~
::

     Instantly disable interrupts.


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     None


Notes
~~~~~
::

     This is low level function, it does not have nesting count
     and state tracking mechanism. It operates directly on the CPU.
     Normal applications should consider using exec.library/Disable().



See also
~~~~~~~~

`KrnSti()`_ 

----------

KrnCreateContext()
==================

Synopsis
~~~~~~~~
::

 void * KrnCreateContext();

Function
~~~~~~~~
::

     Allocate and initialize CPU context storage area.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     A pointer to a CPU context storage area.


Notes
~~~~~
::

     CPU context storage is considered private and accessible
     only from within supevisor mode.



----------

KrnDecodeLocationA()
====================

Synopsis
~~~~~~~~
::

 int KrnDecodeLocationA(
          void * addr,
          struct TagItem * tags );
 
 int KrnDecodeLocation(
          void * addr,
          TAG tag, ... );

Function
~~~~~~~~
::

     Locate the given address in the list of registered modules and return
     information about it.


Inputs
~~~~~~
::

     addr - An address to resolve
     tags - An optional taglist. ti_Tag can be one of the following tags and
            ti_Data is always a pointer to a storage of specified type.
            Resulting values will be placed into specified locations if the
            function succeeds.

         KDL_ModuleName     (char *) - Module name
         KDL_SegmentName    (char *) - Segment name. Can be NULL if there were
                                       no segment names provided for the module.
         KDL_SegmentPointer (BPTR)   - DOS pointer to the corresponding segment.
                                       Note that it will be different from
                                       KDL_SegmentStart value
         
         KDL_SegmentNumber  (unsigned int) - Order number of the segment in the
                                             module
         KDL_SegmentStart   (void *) - Start address of actual segment contents
                                       in memory.
         KDL_SegmentEnd     (void *) - End address of actual segment contents
                                       in memory.
     
         The following tags may return NULL values if there was no corresponding
         information provided for the module:

         KDL_SymbolName     (char *) - Symbol name (function or variable name)
         KDL_SymbolStart    (void *) - Start address of contents described by this
                                       symbol.
         KDL_SymbolEnd      (void *) - End address of contents described by this
                                       symbol.


Result
~~~~~~
::

     Zero if lookup failed and no corresponding module found, nonzero
     otherwise.


Notes
~~~~~
::

     If the function fails values pointed to by taglist will not be changed.



----------

KrnDeleteContext()
==================

Synopsis
~~~~~~~~
::

 void KrnDeleteContext(
          void * context );


----------

KrnDispatch()
=============

Synopsis
~~~~~~~~
::

 void KrnDispatch();


----------

KrnFreePages()
==============

Synopsis
~~~~~~~~
::

 void KrnFreePages(
          void * phy_addr,
          uint32_t length );


----------

KrnGetBootInfo()
================

Synopsis
~~~~~~~~
::

 struct TagItem * KrnGetBootInfo();


----------

KrnGetScheduler()
=================

Synopsis
~~~~~~~~
::

 KRN_SchedType KrnGetScheduler();


----------

KrnIsSuper()
============

Synopsis
~~~~~~~~
::

 int KrnIsSuper();

Function
~~~~~~~~
::

     Determine if the caller is running in supervisor mode


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     Nonzero for supervisor mode, zero for user mode


Notes
~~~~~
::

     Callers should only test the return value against zero.
     Nonzero values may actually be different, since they
     may carry some private implementation-dependent information
     (like CPU privilege level, for example).



----------

KrnMapGlobal()
==============

Synopsis
~~~~~~~~
::

 int KrnMapGlobal(
          void * virtual,
          void * physical,
          uint32_t length,
          KRN_MapAttr flags );


----------

KrnMayGetChar()
===============

Synopsis
~~~~~~~~
::

 int KrnMayGetChar();

Function
~~~~~~~~
::

     Read a single character from low-level debug input stream


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     An ASCII code of the character or -1 if there's no character
     available


Notes
~~~~~
::

     This function never waits. If there is no character available on
     the stream it just returns with -1



----------

KrnPutChar()
============

Synopsis
~~~~~~~~
::

 void KrnPutChar(
          char c );

Function
~~~~~~~~
::

     Output a single character to low-level debug output stream


Inputs
~~~~~~
::

     c - A character to output


Result
~~~~~~
::

     None



----------

KrnRegisterModule()
===================

Synopsis
~~~~~~~~
::

 void KrnRegisterModule(
          const char * name,
          BPTR segList,
          ULONG debugType,
          APTR debugInfo );

Function
~~~~~~~~
::

     Add information about the loaded executable module to the
     debug information database


Inputs
~~~~~~
::

     name      - Module name
     segList   - DOS segment list for the module
     debugType - Type of supplied debug information. The only currently
                 supported type is DEBUG_ELF.
     debugInfo - Debug information data. For DEBUG_ELF type this should be
                 a pointer to struct ELF_DebugInfo, filled in as follows:
                   eh - a pointer to ELF file header with int_shnum and
                        int_shstrndx fields filled in.
                   sh - a pointer to an array of ELF section headers.


Result
~~~~~~
::

     None



----------

KrnRemExceptionHandler()
========================

Synopsis
~~~~~~~~
::

 void KrnRemExceptionHandler(
          void * handle );

Function
~~~~~~~~
::

     Remove previously installed CPU exception handler


Inputs
~~~~~~
::

     handle - an opaque handler returned by KrnAddExceptionHandler()
              function


Result
~~~~~~
::

     None



----------

KrnRemIRQHandler()
==================

Synopsis
~~~~~~~~
::

 void KrnRemIRQHandler(
          void * handle );

Function
~~~~~~~~
::

     Remove previously installed hardware IRQ handler


Inputs
~~~~~~
::

     handle - an opaque handler returned by KrnAddIRQHandler()
              function


Result
~~~~~~
::

     None



----------

KrnSchedule()
=============

Synopsis
~~~~~~~~
::

 void KrnSchedule();


----------

KrnSetProtection()
==================

Synopsis
~~~~~~~~
::

 void KrnSetProtection(
          void * address,
          uint32_t length,
          KRN_MapAttr flags );


----------

KrnSetScheduler()
=================

Synopsis
~~~~~~~~
::

 void KrnSetScheduler(
          KRN_SchedType sched );


----------

KrnSti()
========

Synopsis
~~~~~~~~
::

 void KrnSti();

Function
~~~~~~~~
::

     Instantly enable interrupts.


Inputs
~~~~~~
::

     None


Result
~~~~~~
::

     None


Notes
~~~~~
::

     This is low level function, it does not have nesting count
     and state tracking mechanism. It operates directly on the CPU.
     Normal applications should consider using exec.library/Enable().



See also
~~~~~~~~

`KrnCli()`_ 

----------

KrnSwitch()
===========

Synopsis
~~~~~~~~
::

 void KrnSwitch();


----------

KrnUnmapGlobal()
================

Synopsis
~~~~~~~~
::

 int KrnUnmapGlobal(
          void * virtual,
          uint32_t length );


----------

KrnUnregisterModule()
=====================

Synopsis
~~~~~~~~
::

 void KrnUnregisterModule(
          BPTR segList );

Function
~~~~~~~~
::

     Remove previously registered module from the debug information database


Inputs
~~~~~~
::

     segList - DOS segment list for the module to remove


Result
~~~~~~
::

     None


Notes
~~~~~
::

     The function correctly supports partial removal of the module
     (when an existing seglist is broken and only a part of the module
     is unloaded).



----------

KrnVirtualToPhysical()
======================

Synopsis
~~~~~~~~
::

 void * KrnVirtualToPhysical(
          void * virtual );


